[{"title":"Home","headers":[{"level":2,"title":"üí° About Javacord","slug":"about-javacord"},{"level":2,"title":"üë©‚Äçüè´ Learn more","slug":"learn-more"},{"level":2,"title":"ü§ù Discord Server","slug":"discord-server"}],"content":"\n## :bulb: About Javacord\n\nJavacord is a modern library that focuses on simplicity and speed üöÄ.\nBy reducing itself to standard Java classes and features like\n[`Optional`](wiki/essential-knowledge/optionals.html)s and \n[`CompletableFuture`](wiki/essential-knowledge/completable-futures.html)s, \nit is extremely easy to use for every Java developer, as it does not require you to learn any\n new frameworks or complex abstractions. \nIt has rich documentation and an **awesome community** :muscle: on Discord that loves to help with any\nspecific problems and questions.\n\n## :woman_teacher: Learn more\n\nThis website is the home to our wiki for everyone who want to learn Javacord.\nIf you haven't already, you should first take a look at our [GitHub page](https://github.com/Javacord/Javacord)\nbefore you continue with the wiki.\n\n## :handshake: Discord Server\n\nDid you know that Javacord has a Discord server?\nNo? Well, now you do! :wink:\n\nJavacord's Discord community is an excellent resource if you have questions about the library.\nYou can join it by clicking :point_right: [**here**](https://discord.gg/0qJ2jjyneLEgG7y3) :point_left:.","path":"/","keywords":[]},{"title":"Imprint","content":"\n# Imprint\n\n<iframe src=\"/im.html\" style=\"height: calc(100vh - 250px); width: 100%\"></iframe>","path":"/imprint.html","keywords":[]},{"title":"Privacy Policy","content":"\n# Privacy Policy\n\n<iframe src=\"/pp.html\" style=\"height: calc(100vh - 250px); width: 100%\"></iframe>","path":"/privacy-policy.html","keywords":[]},{"title":"Bot Lifecycle","headers":[{"level":2,"title":"üí° The four states","slug":"the-four-states"},{"level":3,"title":"Connected","slug":"connected"},{"level":3,"title":"Disconnected","slug":"disconnected"},{"level":3,"title":"Resuming","slug":"resuming"},{"level":3,"title":"Reconnecting","slug":"reconnecting"},{"level":2,"title":"üíä How to handle disconnects","slug":"how-to-handle-disconnects"}],"content":"\n# Bot Lifecycle\n\nIt's important to know the life-cycle of a discord bot to properly handle disconnects. \nThe following state diagram shows the 4 states a bot can have:\n\n![](https://javacord.org/img/tutorials/bot-life-cycle/state-diagram.svg)\n\n## :bulb: The four states\n\n### Connected\n\nThe bot is connected to the websocket and receives all events.\n\n### Disconnected\n\nThe bot is not connected to the websocket and receives no events. It's not uncommon for a bot to occasionally lose connection.\nThis can have various reasons, for example:\n* Your bot lost its internet connection\n* Discord restarted the gateway server you are currently connected to\n* A plane crashed into Discord's data center\n\nThe bot will periodically try to resume/reconnect to the websocket. It will start with a small frequency and increase it\nwith every failed reconnect attempt. You can modify the reconnect delay with the `DiscordApi#setReconnectDelay(...)` method.\nThe following example code would increase the delay linearly.\nThe 1st attempt would be delayed for `2` seconds, the 2nd attempt for `4` seconds, the 3rd attempts for `6` seconds, ...\n```java\napi.setReconnectDelay(attempt -> attempt * 2);\n```\n\n> **Important:** Bots can only reconnect 1000 times in a 24-hour period (every ~90 seconds). This limit is global and across all shards.\n Upon hitting this limit, all active sessions for the bot will be terminated, the bot's token will be reset, and\n you will receive an email notification. This is the reason Javacord increases the reconnect delay with every attempt.\n\nBy default, the $default\\_delay$ formula below is used to calculate the reconnect delay\n\n$$\ndefault\\_delay(a) = \\lfloor a^{1.5} - \\frac{a^{1.5}}{\\frac{1}{(0.1 \\cdot a)} + 1} \\rceil\n$$\n\nwith $a$ being the attempt.\n\nThe formula will generate the following reconnect delay:\n\n| Attempt | Delay |\n| ------- | ----- |\n| 1       | 1     |\n| 2       | 2     |\n| 3       | 4     |\n| 4       | 6     |\n| 5       | 7     |\n| ...     | ...   |\n| 10      | 16    |\n| 15      | 23    |\n| 20      | 30    |\n| ...     | ...   |\n| 50      | 59    |\n| 100     | 91    |\n| 150     | 115   |\n| ...     | ...   |\n\n### Resuming\n\nResuming is only possible for a short time after being disconnected. If the bot can successfully resume the connection,\nyou will not miss any events. Your bot will receive all events you missed while being disconnected. The cache gets updated\naccordingly.\n\n### Reconnecting\n\nIf your bot reconnects (not resumes!), the whole cache gets wiped, and you will not receive any missed events.  \n\n**What does this mean?**  \n* References to entities (e.g. a `Server`, `User`, `Channel`, ...) will be outdated. This is why you should never store\n  entities, but the id instead. See [Entity Cache](/wiki/advanced-topics/entity-cache.md#how-long-are-cached-entities-valid).\n* You will miss events. There's no way to receive the missed events.\n* Listeners attached to entities will **not** be affected, because they are bound to the entity's id, not the object itself.\n\n## :pill: How to handle disconnects\n\nFor most bots, there's nothing you have to do. All registered listeners are reconnect-resistant, which means if your bot\nis only reacting to events, it will work fine after a restart. For example, the following code will not be affected by a \nreconnect (besides maybe some missed `!ping` messages):\n```java\napi.addMessageCreateListener(event -> {\n    if (event.getMessage().getContent().equalsIgnoreCase(\"!ping\")) {\n        event.getChannel().sendMessage(\"Pong!\");\n    }\n});\n```\n\nIn case you want to handle reconnects (e.g. fetch the message history to detect missed messages), there are\nspecial connection-related listeners which can be used to track the state of the bot:\n* `LostConnectionListener`\n* `ReconnectListener`\n* `ResumeListener`\n","path":"/wiki/advanced-topics/bot-lifecycle.html","keywords":["resume","reconnect","lifecycle","unavailable"]},{"title":"Entity Cache","headers":[{"level":2,"title":"üîÆ What is in the cache?","slug":"what-is-in-the-cache"},{"level":2,"title":"‚ùì When are cached entities updated?","slug":"when-are-cached-entities-updated"},{"level":2,"title":"‚åöÔ∏è How long are cached entities valid?","slug":"how-long-are-cached-entities-valid"}],"content":"\n# Entity Cache\n\nJavacord keeps an internal cache for entities (e.g. Servers, Channels, Users, ...). It is important to know how the cache behaves to properly use it.\n\n## :crystal_ball: What is in the cache?\n\nNearly every entity known by the bot is guaranteed to be in the cache. There are a few exceptions though:\n\n#### Users\n\nUsers are only cached when you have the `GUILD_MEMBERS` intent enabled.\nSee [Gateway Intents](/wiki/basic-tutorials/gateway-intents/) for more information.\n\n#### Messages\n\nNot every single message is in the cache, which means you can encounter messages which exist but are not in the cache. This can happen for most message events, e.g. the [`ReactionAddEvent`](https://ci.javacord.org/javadoc/org/javacord/api/event/message/reaction/ReactionAddEvent.html). You can, however, interact with these messages without having them in the cache. Every message event has methods like `event.deleteMessage()`, `event.editMessage(\"New Content\")`. If you need the message (e.g. to get its content), you can request it using `event.requestMessage()`.\n\nAdditionally, you can use the static methods in the [`Message`](https://ci.javacord.org/javadoc/org/javacord/api/entity/message/Message.html) class which only require the channel and message id, e.g. `Message.edit(api, channelId, messageId, \"New content\");`. This is very useful if you want to store them in a database.\n\n#### Webhooks and Invites\n\nWebhooks and Invites are not kept in the cache at all and won't receive any updates.\n\n#### Embeds\n\nEmbeds from `message.getEmbed()` won't receive updates. If a message's embed gets edited, `getEmbed()` will return a completely new embed object.\n\n## :question: When are cached entities updated?\n\nJavacord's cache exclusively uses websocket events to keep the cache up to date. This means that the content of your objects might be outdated, even though you modified it yourself:\n\n```java\nMessages message = ...;\nSystem.out.println(message.getContent()); // Prints the old content, e.g. \"old content\"\nmessage.edit(\"new content\").join(); // Edits the message and waits for success\nSystem.out.println(message.getContent()); // Still prints \"old content\"\nThread.sleep(1000);\nSystem.out.println(message.getContent()); // Most likely prints \"new content\" now\n```\n\n## :watch: How long are cached entities valid?\n\nEven though entities are usually kept in the cache for a very long time, you should not keep references to these objects for a longer period of time, but store the id / use event methods:\n\n```java\n// Bad\nMessage message = ...;\nmessage.addReactionAddListener(event -> {\n  if (event.getEmoji().equalsEmoji(\"üëé\")) {\n    message.delete(); // Prevents \"message\" from being garbage collected\n  }\n});\n\n// Good\nMessage message = ...;\nmessage.addReactionAddListener(event -> {\n  if (event.getEmoji().equalsEmoji(\"üëé\")) {\n    event.deleteMessage(); // Does not use the message object\n  }\n});\n```\n\n```java\n// Bad\nSet<User> usersWithBadMood = new HashSet<>();\napi.addReactionAddListener(event -> {\n  if (event.getEmoji().equalsEmoji(\"üò¶\")) {\n    usersWithBadMood.add(event.getUser());\n  }\n});\n\n// Good\nSet<Long> usersWithBadMood = new HashSet<>();\napi.addReactionAddListener(event -> {\n  if (event.getEmoji().equalsEmoji(\"üò¶\")) {\n    usersWithBadMood.add(event.getUser().getId());\n  }\n});\n```\n\nSome examples of when cached entities are invalidated:\n* The bot lost its connection to Discord and had to reconnect (not resume)\n* You weren't able to receive updates for an entity, e.g. for `Channel`, because you left and rejoined a server","path":"/wiki/advanced-topics/entity-cache.html","keywords":["entity","cache","caching"]},{"title":"Performance Tweaks","headers":[{"level":2,"title":"‚úÇÔ∏è Disabling Startup Wait","slug":"disabling-startup-wait"},{"level":2,"title":"‚öôÔ∏è Fine Tuning the Message Cache","slug":"fine-tuning-the-message-cache"},{"level":2,"title":"üíé Using the Updater classes","slug":"using-the-updater-classes"},{"level":3,"title":"Example","slug":"example"}],"content":"\n# Performance Tweaks\n\n## :scissors: Disabling Startup Wait\n\nBy default, Javacord waits for all servers and members to be loaded on startup. You can disable this behavior in the `DiscordApiBuilder` before logging in:\n```java\nnew DiscordApiBuilder()\n    .setToken(\"abc\")\n    .setWaitForServersOnStartup(false)\n    .login()\n    .thenAccept(api -> {\n        // Do something\n    }).exceptionally(ExceptionLogger.get());\n```\nDepending on the size of your bot, this can significantly speed up the login process. This comes with one downside however: The `api.getServers()` collection is empty directly after logging in. You will receive `ServerBecomesAvailableEvent`s for every server which finished loading.\n\n## :gear: Fine Tuning the Message Cache\n\nIn order to reduce memory usage, you can completely disable the message cache or reduce the number of cached messages. By default, Javacord caches up to 50 messages per channel and removes messages from the cache which are older than 12 hours. You can lower this limit by using `DiscordApi#setMessageCacheSize(Capacity, StorageTimeInSeconds)`.\n```java\n// Cache a maximum of 10 messages per channel for and remove messages older than 1 hour\napi.setMessageCacheSize(10, 60*60);\n```\nYou can even set this limit on a per-channel basis:\n```java\nTextChannel channel = ...;\nchannel.getMessageCache().setCapacity(10);\nchannel.getMessageCache().setStorageTimeInSeconds(60*60);\n```\n\n## :gem: Using the Updater classes\n\nIf you update several settings of an entity (server, channel, ...) at once, you should use the updater for this entity instead of the `updateXyz(...)` methods.\n\n### Example\n\n```java\n// Sends 1 request to Discord\nServerTextChannel channel = ...;\nnew ServerTextChannelUpdater(channel)\n    .setName(\"example-channel\")\n    .setTopic(\"This is an example channel\")\n    .setNsfwFlag(true)\n    .update();\n```\ninstead of\n```java\n// Sends 3 requests to Discord\nServerTextChannel channel = ...;\nchannel.updateName(\"example-channel\");\nchannel.updateTopic(\"This is an example channel\");\nchannel.updateNsfwFlag(true);\n```","path":"/wiki/advanced-topics/performance-tweaks.html","keywords":["performance","tweaks","startup wait","message cache","tuning"]},{"title":"Playing Audio","headers":[{"level":2,"title":"üîå Connect to a voice channel","slug":"connect-to-a-voice-channel"},{"level":3,"title":"Example","slug":"example"},{"level":2,"title":"üëÇ Playing music","slug":"playing-music"}],"content":"\n# Playing Audio\n\n::: warning\nSupport for audio was added to Javacord very recently.\nIf you encounter any bugs, please [create an issue on GitHub](https://github.com/Javacord/Javacord/issues/new)!\n:::\n\nJavacord allows your bot to connect to voice channels and play audio (e.g., music).\nThis short tutorial gives you an introduction on how to connect to a voice channel and play your \n[favorite music](https://youtu.be/qRC4Vk6kisY).\n\n## :electric_plug: Connect to a voice channel\n\nConnecting to a voice channel is very straight forward:\nCalling `#connect()` on an instance of `ServerVoiceChannel` will connect your bot to this voice channel and\nreturn a [future](/wiki/essential-knowledge/completable-futures/) with an `AudioConnection` object.\n\n### Example\n\nThe following example will connect the bot to the voice channel of the user that typed `!music` in the chat:\n\n```java\nServerVoiceChannel channel = ...;\nchannel.connect().thenAccept(audioConnection -> {\n    // Do stuff\n}).exceptionally(e -> {\n    // Failed to connect to voice channel (no permissions?)\n    e.printStackTrace();\n    return null;\n});\n```\n\n## :ear: Playing music\n\nThere are plenty of sources for audio (e.g., YouTube, local files, etc.).\nThe current de facto standard library for extracting audio from these sources with Java is the\n[LavaPlayer](https://github.com/sedmelluq/lavaplayer) library.\n\nTo use it with Javacord, you have to add it as a dependency to your project (e.g., with Gradle or Maven) and\ncreate a Javacord audio source like this:\n\n```java\npublic class LavaplayerAudioSource extends AudioSourceBase {\n\n    private final AudioPlayer audioPlayer;\n    private AudioFrame lastFrame;\n\n    /**\n     * Creates a new lavaplayer audio source.\n     *\n     * @param api A discord api instance.\n     * @param audioPlayer An audio player from Lavaplayer.\n     */\n    public LavaplayerAudioSource(DiscordApi api, AudioPlayer audioPlayer) {\n        super(api);\n        this.audioPlayer = audioPlayer;\n    }\n\n    @Override\n    public byte[] getNextFrame() {\n        if (lastFrame == null) {\n            return null;\n        }\n        return applyTransformers(lastFrame.getData());\n    }\n\n    @Override\n    public boolean hasFinished() {\n        return false;\n    }\n\n    @Override\n    public boolean hasNextFrame() {\n        lastFrame = audioPlayer.provide();\n        return lastFrame != null;\n    }\n\n    @Override\n    public AudioSource copy() {\n        return new LavaplayerAudioSource(getApi(), audioPlayer);\n    }\n}\n```\n\nWith this audio source, you can now start using Lavaplayer, e.g. to play a YouTube video:\n```java\n// Create a player manager\nAudioPlayerManager playerManager = new DefaultAudioPlayerManager();\nplayerManager.registerSourceManager(new YoutubeAudioSourceManager());\nAudioPlayer player = playerManager.createPlayer();\n\n// Create an audio source and add it to the audio connection's queue\nAudioSource source = new LavaplayerAudioSource(api, player);\naudioConnection.setAudioSource(source);\n\n// You can now use the AudioPlayer like you would normally do with Lavaplayer, e.g.,\nplayerManager.loadItem(\"https://www.youtube.com/watch?v=NvS351QKFV4\", new AudioLoadResultHandler() {\n    @Override\n    public void trackLoaded(AudioTrack track) {\n        player.playTrack(track);\n    }\n\n    @Override\n    public void playlistLoaded(AudioPlaylist playlist) {\n        for (AudioTrack track : playlist.getTracks()) {\n            player.playTrack(track);\n        }\n    }\n\n    @Override\n    public void noMatches() {\n        // Notify the user that we've got nothing\n    }\n\n    @Override\n    public void loadFailed(FriendlyException throwable) {\n        // Notify the user that everything exploded\n    }\n}\n```\n","path":"/wiki/advanced-topics/playing-audio.html","keywords":["audio","music","voice"]},{"title":"Proxies","headers":[{"level":2,"title":"üë®‚Äçüíª Configuring a Proxy ...","slug":"configuring-a-proxy"},{"level":3,"title":"... using System Properties","slug":"using-system-properties"},{"level":3,"title":"... using a System Default Proxy Selector","slug":"using-a-system-default-proxy-selector"},{"level":3,"title":"... using an Explicitly Set Proxy","slug":"using-an-explicitly-set-proxy"},{"level":3,"title":"... using an Explicitly Set Proxy Selector","slug":"using-an-explicitly-set-proxy-selector"},{"level":3,"title":"Precedence of the Configuration Options","slug":"precedence-of-the-configuration-options"},{"level":2,"title":"üîë Configuring Proxy Authentication ...","slug":"configuring-proxy-authentication"},{"level":3,"title":"... using a System Default Authenticator","slug":"using-a-system-default-authenticator"},{"level":3,"title":"... using an Explicitly Set Authenticator","slug":"using-an-explicitly-set-authenticator"},{"level":2,"title":"üí° Proxy Types","slug":"proxy-types"},{"level":3,"title":"HTTP","slug":"http"},{"level":3,"title":"SOCKS 4","slug":"socks-4"},{"level":3,"title":"SOCKS 4a","slug":"socks-4a"},{"level":3,"title":"SOCKS 5","slug":"socks-5"}],"content":"\n# Proxies\n\nThere are basically two kinds of proxies: HTTP proxies and SOCKS proxies. Both may or may not support or require authentication depending on version, capabilities, and configuration. Due to the underlying libraries used, currently, Javacord fully supports HTTP proxies and partially supports SOCKS proxies.\n\nJavacord uses HTTPS connections to communicate with the Discord REST API and a WSS connection to communicate with the Discord WebSocket endpoint. Both these protocols are secure protocols and thus do not honor settings for HTTP connections, only settings for HTTPS connections.\n\n## :man_technologist: Configuring a Proxy ...\n\n### ... using System Properties\n\nIf you did not explicitly set a proxy in the `DiscordApiBuilder` and did not set a system default `ProxySelector`, the default proxy selector of the JRE is used. This proxy selector honors, amongst others, the relevant standard system properties `https.proxyHost`, `https.proxyPort`, `socksProxyHost`, `socksProxyPort`, and `socksProxyVersion`. Use the former two to configure an HTTP proxy, or the latter three to configure a SOCKS proxy, although you will not need `socksProxyVersion`, as SOCKS4 is currently not supported.\n\n### ... using a System Default Proxy Selector\n\nYou can use `java.net.ProxySelector.setDefault(ProxySelector)` to set a system default proxy selector that replaces the default one. In its implementation, you can dynamically determine which proxy to use for each connection.\n\n### ... using an Explicitly Set Proxy\n\nUsing the method `DiscordApiBuilder.setProxy(Proxy)` you can set a proxy instance directly in the `DiscordApiBuilder` that is solely used for Javacord connections and does not affect the unrelated code running in the JVM.\n\n### ... using an Explicitly Set Proxy Selector\n\nUsing the method `DiscordApiBuilder.setProxySelector(ProxySelector)` you can set a proxy selector instance directly in the `DiscordApiBuilder` that is solely used for Javacord connections and does not affect the remaining code running in the JVM. In its implementation, you can dynamically determine which proxy to use for each connection.\n\n### Precedence of the Configuration Options\n\n* if an explicit proxy is set, it is used\n* if an explicit proxy selector is set, it is used\n* if both an explicit proxy and an explicit proxy selector are set, this is a configuration error and will cause an exception to be thrown\n* if neither explicit option is set, the system default proxy selector is used\n* if no system default proxy selector was explicitly set, the JRE default that honors the system properties is used\n\n## :key: Configuring Proxy Authentication ...\n\n### ... using a System Default Authenticator\n\nYou can use `java.net.Authenticator.setDefault(Authenticator)` to set a system default authenticator that is used to provide username and password pairs for connections. This authenticator is only used if the proxy supports the `Basic` authentication scheme. If you need to support any other authentication scheme, use an explicitly configured authenticator. The `java.net.Authenticator` interface is too inflexible to support this.\n\n### ... using an Explicitly Set Authenticator\n\nUsing the method `DiscordApiBuilder.setProxyAuthenticator(Authenticator)`, you can set a custom authenticator that is much more powerful than the `java.net.Authenticator`. You get much more information about the connection to be established, and you can return any HTTP header that is necessary for a successful authentication. This should cover all sorts of available authentication mechanisms.\n\n## :bulb: Proxy Types\n\n### HTTP\n\nHTTP proxies are fully supported.\n\n### SOCKS 4\n\nSOCKS 4 is currently not supported.\n\nThe WebSocket library we use does not support SOCKS proxies at all, and the HTTP library we use has a bug that prevents SOCKS 4 to be used. Additionally, you would need to use at least Java 9 or a separate socket factory supporting SOCKS 4, as the JRE implementation is not working in Java 8 and got fixed only in Java 9+.\n\n### SOCKS 4a\n\nSOCKS 4a is currently only partially supported.\n\nThe WebSocket library we use does not support SOCKS proxies at all, so it could be used for the REST connections only. Additionally, you would need to use a separate socket factory supporting SOCKS 4a, as the JRE implementation is not capable of doing SOCKS 4a, only SOCKS 4 and SOCKS 5 are supported at the time of creation of this wiki article.\n\n### SOCKS 5\n\nSOCKS 5 is currently only partially supported.\n\nThe WebSocket library we use does not support SOCKS proxies at all, so it could be used for the REST connections only.","path":"/wiki/advanced-topics/proxies.html","keywords":["proxy","connection","socks","socks4","socks5"]},{"title":"Ratelimits","headers":[{"level":2,"title":"‚ùóÔ∏è The Most Important Ratelimits","slug":"the-most-important-ratelimits"},{"level":2,"title":"üí™ Dealing with Ratelimits","slug":"dealing-with-ratelimits"},{"level":3,"title":"Example","slug":"example"},{"level":2,"title":"‚ùå Can I disable ratelimits?","slug":"can-i-disable-ratelimits"}],"content":"\n# Ratelimits\n\nRatelimits is a Discord restriction which prevents you from performing actions in a very fast rate.\nMost ratelimits are on a per-channel or a per-server basis.\n\n## :exclamation: The Most Important Ratelimits\n\n| Action               | Ratelimit | Type        |\n| -------------------- | --------- | ----------- |\n| Send Messages        | 5 / 5s    | per channel |\n| Delete Messages      | 5 / 1s    | per channel |\n| Add/Remove Reactions | 1 / 0.25s | per channel |\n| Edit Server Members  | 10 / 10s  | per server  |\n| Edit Member Nickname | 1 / 1s    | per server  |\n| Edit Bot Username    | 2 / 1h    | per account |\n| Update Channels      | 2 / 10m   | per account |\n| All Actions Combined | 50 / 1s   | per account |\n\n## :muscle: Dealing with Ratelimits\n\nUsually Javacord takes care about these limitations for you. \nAs a user, there's nothing you have to do, but you should at least know that ratelimits exist.\n\n### Example\n\nThe following code\n```java\n// Who even needs loops?\nchannel.sendMessage(\"Ratelimit Example #1\");\nchannel.sendMessage(\"Ratelimit Example #2\");\nchannel.sendMessage(\"Ratelimit Example #3\");\nchannel.sendMessage(\"Ratelimit Example #4\");\nchannel.sendMessage(\"Ratelimit Example #5\");\nchannel.sendMessage(\"Ratelimit Example #6\");\nchannel.sendMessage(\"Ratelimit Example #7\");\nchannel.sendMessage(\"Ratelimit Example #8\");\nchannel.sendMessage(\"Ratelimit Example #9\");\nchannel.sendMessage(\"Ratelimit Example #10\");\nchannel.sendMessage(\"Ratelimit Example #11\");\nchannel.sendMessage(\"Ratelimit Example #12\");\n```\n\nwould look like this in the client:\n\n>![](https://i.imgur.com/ailPCdH.gif)\n\nYou can clearly see the delay between every 5 sent messages.\n\n## :x: Can I disable ratelimits?\n\nNo. Ratelimits are a limitation from Discord itself, which you cannot circumvent.","path":"/wiki/advanced-topics/ratelimits.html","keywords":["ratelimits"]},{"title":"Sharding","headers":[{"level":2,"title":"üë©‚Äçüè≠ Sharding in Javacord","slug":"sharding-in-javacord"},{"level":3,"title":"Logging in with a single shard","slug":"logging-in-with-a-single-shard"},{"level":3,"title":"Logging in with a fixed amount of shards","slug":"logging-in-with-a-fixed-amount-of-shards"},{"level":3,"title":"Using the recommended shard amount","slug":"using-the-recommended-shard-amount"},{"level":2,"title":"üí° Behavior of Shards","slug":"behavior-of-shards"},{"level":3,"title":"Managed servers","slug":"managed-servers"},{"level":3,"title":"Private messages","slug":"private-messages"},{"level":3,"title":"When do I need sharding?","slug":"when-do-i-need-sharding"},{"level":2,"title":"üåÑ Sharding for Very Large Bots","slug":"sharding-for-very-large-bots"}],"content":"\n# Sharding\n\nDiscord allows (and forces) you to \"split\" larger bots into several independent parts. This behavior is called \"sharding\", and the independent parts are called \"shards\". You can think of shards as completely independent bots. Every shard is responsible for a disjoint set of servers.\n\n## :woman_factory_worker: Sharding in Javacord\n\n### Logging in with a single shard\n\nLogging in with a single shard is pretty much the same as logging in without sharding:\n```java\nDiscordApi api = new DiscordApiBuilder()\n    .setToken(\"top secret\")\n    .setCurrentShard(0)\n    .setTotalShards(2)\n    .login().join();\nSystem.out.println(\"Shard \" + api.getCurrentShard() + \" logged in!\");\n```\n> **Note**: `current shard` starts counting at `0`! This means in the example above you would have current shard `0` and shard `1` with a `total amount` of `2` shards.\n\n> **Important**: There must be a > 5-second delay between each shard-login\n\n### Logging in with a fixed amount of shards\n\nYou can manually set a fixed amount of total shards and log in all of them:\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        new DiscordApiBuilder()\n            .setToken(\"top secret\")\n            .setTotalShards(10)\n            .loginAllShards()\n            .forEach(shardFuture -> shardFuture\n                .thenAcceptAsync(Main::onShardLogin)\n                .exceptionally(ExceptionLogger.get())\n            );\n    }\n\n    private static void onShardLogin(DiscordApi api) {\n        System.out.println(\"Shard \" + api.getCurrentShard() + \" logged in!\");\n        // You can treat the shard like a normal bot account, e.g. registering listeners\n        api.addMessageCreateListener(event -> {\n            // ...\n        });\n    }\n\n}\n```\n`loginAllShards()` returns a collection with completable futures (`Collection<CompletableFuture<DiscordApi>>`). This method automatically obeys the > 5-second delay rule.\n\n### Using the recommended shard amount\n\nYou can \"ask\" Discord to recommend you a total amount of shards. This is done by using the `DiscordApiBuilder#setRecommendedTotalShards()` method, which returns a `CompletableFuture<DiscordApiBuilder>` after getting the required information.\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        new DiscordApiBuilder()\n            .setToken(\"top secret\")\n            .setRecommendedTotalShards().join()\n            .loginAllShards()\n            .forEach(shardFuture -> shardFuture\n                .thenAccept(Main::onShardLogin)\n                .exceptionally(ExceptionLogger.get())\n            );\n    }\n\n    private static void onShardLogin(DiscordApi api) {\n        // ...\n    }\n\n}\n```\n\n## :bulb: Behavior of Shards\n\n### Managed servers\n\nYou can calculate for which servers a shard is responsible using the server id:\n```java\nboolean isResponsible = (serverId >> 22) % totalShards == currentShard;\n```\n\n### Private messages\n\nPrivate messages are always sent to the first shard (`currentShard == 0`).\n\n### When do I need sharding?\n\nSharding is forced for bots which are in more than 2500 servers.\n\n## :sunrise_over_mountains: Sharding for Very Large Bots\n\nSharding for very large bots (> 100,000 servers) is a bit different from \"normal\" sharding. Discord will contact you once your bot reaches this state. Additional information can be found in the [official Discord api documentation](https://discordapp.com/developers/docs/topics/gateway#sharding-for-very-large-bots).","path":"/wiki/advanced-topics/sharding.html","keywords":["sharding","large"]},{"title":"Creating Channels, Invites, etc.","headers":[{"level":2,"title":"üìï Create Channels","slug":"create-channels"},{"level":2,"title":"üìó Create Webhooks","slug":"create-webhooks"},{"level":2,"title":"üìò Create Invites","slug":"create-invites"},{"level":2,"title":"üìô Create Servers","slug":"create-servers"}],"content":"# Creating Channels, Invites, etc.\n\nJavacord provides `XyzBuilder` classes to create new Discord entities like channels, webhooks, servers, and many more.\n\n## :closed_book: Create Channels\n\nYou can get the channel builders for a specific server using the `Server#createXyzChannelBuilder` or by directly calling the constructor.\nCreating a `ServerVoiceChannel` would look like this:\n```java\nServer server = ...;\nServerVoiceChannel channel = new ServerVoiceChannelBuilder(server)\n    .setName(\"example-channel\")\n    .setUserlimit(10)\n    .create().join();\n```\n\n## :green_book: Create Webhooks\n\nYou can get the `WebhookBuilder` for a specific text channel:\n\n```java\nServerTextChannel channel = ...;\nWebhook webhook = new WebhookBuilder(channel)\n    .setName(\"Captain Hook\")\n    .setAvatar(new File(\"C:/Users/Bastian/Pictures/puppy.jpg\"))\n    .create().join();\n```\n\n## :blue_book: Create Invites\n\nYou can get the `InviteBuilder` for a specific server channel:\n```java\nServerTextChannel channel = ...;\nInvite invite = new InviteBuilder(channel)\n    .setMaxAgeInSeconds(60*60*24)\n    .setMaxUses(42)\n    .create().join();\n```\n\n## :orange_book: Create Servers\n\nYou can get the `ServerBuilder` from the current api instance:\n```java\nDiscordApi api = ...;\nlong serverId = new ServerBuilder(api)\n    .setName(\"My Awesome Server\")\n    .setIcon(api.getYourself().getAvatar())\n    .setVerificationLevel(VerificationLevel.HIGH)\n    .setDefaultMessageNotificationLevel(DefaultMessageNotificationLevel.ONLY_MENTIONS)\n    .setRegion(Region.EU_CENTRAL)\n    .create().join();\n```\n\n::: warning\nBy default, bots can only create servers if they are in less than 10 servers. You can contact the Discord support to request a higher limit.\n:::","path":"/wiki/basic-tutorials/creating-entities.html","keywords":["creating entities","create entities","entity creation","create channels","channel creation","create webhooks","webhook creation","create invites","invite creation","create server","server creation"]},{"title":"Embeds","headers":[{"level":2,"title":"üî® Creating an Embed","slug":"creating-an-embed"},{"level":2,"title":"üì∑ Supported Image Sources","slug":"supported-image-sources"},{"level":2,"title":"üîí Embed Limits","slug":"embed-limits"},{"level":2,"title":"‚ùì FAQ","slug":"faq"},{"level":3,"title":"What is the second parameter of setAuthor(...)?","slug":"what-is-the-second-parameter-of-setauthor"},{"level":3,"title":"What's the difference between an inline field and a normal one?","slug":"what-s-the-difference-between-an-inline-field-and-a-normal-one"},{"level":3,"title":"Can I change the placement of inline fields?","slug":"can-i-change-the-placement-of-inline-fields"},{"level":3,"title":"How can I format text in an embed?","slug":"how-can-i-format-text-in-an-embed"}],"content":"\n# Embeds\n\nEmbeds are attached to messages and have a special design.\nThe usually look like this:\n\n![Embed](https://i.imgur.com/QYbXmQU.png)\n\n## :hammer: Creating an Embed\n\nJavacord provides an `EmbedBuilder` which can be used to create embeds:\n```java\n// Create the embed\nEmbedBuilder embed = new EmbedBuilder()\n    .setTitle(\"Title\")\n    .setDescription(\"Description\")\n    .setAuthor(\"Author Name\", \"http://google.com/\", \"https://cdn.discordapp.com/embed/avatars/0.png\")\n    .addField(\"A field\", \"Some text inside the field\")\n    .addInlineField(\"An inline field\", \"More text\")\n    .addInlineField(\"Another inline field\", \"Even more text\")\n    .setColor(Color.BLUE)\n    .setFooter(\"Footer\", \"https://cdn.discordapp.com/embed/avatars/1.png\")\n    .setImage(new File(\"C:/Users/Bastian/Pictures/puppy.jpg\"))\n    .setThumbnail(new File(\"C:/Users/Bastian/Pictures/kitten2.png\"));\n// Send the embed\nchannel.sendMessage(embed);\n```\n\n## :camera: Supported Image Sources\n\nBy default, Discord expects embed images to be a link (e.g., the image link used in `setFooter(...)`), but you can also use attachments for images.\nIf you provide a non-url image source (e.g. the `puppy.jpg` file used in `setImage(...)`), Javacord automatically uploads them as an attachment to the message and uses this attachment for the embed.\n\n## :lock: Embed Limits\n\n| Type         | Limit           |\n| ------------ | --------------- |\n| Title        | 256 characters  |\n| Description  | 4096 characters |\n| Field Amount | Up to 25 fields |\n| Field Name   | 256 characters  |\n| Field Value  | 1024 characters |\n| Footer Text  | 2048 characters |\n| Author Name  | 256 characters  |\n\nIn addition to the limits above, the sum of all characters in an embed structure must not exceed 6000 characters.\n\n## :question: FAQ\n\n### What is the second parameter of `setAuthor(...)`?\n\n```java\n.setAuthor(\"Author Name\", \"http://google.com/\", \"https://cdn.discordapp.com/embed/avatars/0.png\")\n```\n* First parameter: The name of the author\n* Second parameter: A link for the author (e.g. their homepage). Can be `null`.\n* Third parameter: The avatar of the author\n> ![](https://i.imgur.com/SyE0e88.png)\n\n### What's the difference between an inline field and a normal one?\nNormal fields always start in a new line, whereas several inline fields can be in the same line.\n\n### Can I change the placement of inline fields?\n\nNo, Discord does not allow different embed layouts.\n\n### How can I format text in an embed?\n\nDiscord allows for a subset of markdown to be used. See [their docs](https://support.discord.com/hc/en-us/articles/210298617-Markdown-Text-101-Chat-Formatting-Bold-Italic-Underline-) for the specifics.\n","path":"/wiki/basic-tutorials/embeds.html","keywords":["EmbedBuilder","inline field","setTitle","setDescription","setAuthor","addField","addInlineField","setColor","setFooter","setImage","setThumbnail"]},{"title":"Emojis and Reactions","headers":[{"level":2,"title":"üö¥ Unicode Emojis","slug":"unicode-emojis"},{"level":3,"title":"What are Unicode emojis?","slug":"what-are-unicode-emojis"},{"level":3,"title":"How to use them in messages","slug":"how-to-use-them-in-messages"},{"level":3,"title":"How to use them for reactions","slug":"how-to-use-them-for-reactions"},{"level":2,"title":"ü§∏‚Äç‚ôÄ Custom Emojis","slug":"custom-emojis"},{"level":3,"title":"What are custom emojis?","slug":"what-are-custom-emojis"},{"level":3,"title":"How to use them in messages","slug":"how-to-use-them-in-messages-2"},{"level":3,"title":"How to use them for reactions","slug":"how-to-use-them-for-reactions-2"},{"level":3,"title":"How to get the tag","slug":"how-to-get-the-tag"},{"level":2,"title":"üëë Javacord Emoji \"Hierarchy\"","slug":"javacord-emoji-hierarchy"},{"level":3,"title":"What is a KnownCustomEmoji?","slug":"what-is-a-knowncustomemoji"},{"level":2,"title":"üëå Recommended libraries","slug":"recommended-libraries"}],"content":"# Emojis and Reactions\n\nThere are two different kinds of emojis in Discord: Unicode emojis and custom emojis.\n\n## :biking_man: Unicode Emojis\n\n### What are Unicode emojis?\n\nUnicode emojis are \"normal\" text emojis which are supported by (nearly) all chat clients, including Discord. You can find a list with all Unicode emojis here: [Full Emoji List](https://unicode.org/emoji/charts/full-emoji-list.html).\n\n### How to use them in messages\n\nYou can either directly add them in your code, e.g.\n```java\nchannel.sendMessage(\"Hi! üòÉ\");\n```\nor use the normal \"tag\" like you would in the Client:\n```java\nchannel.sendMessage(\"Hi! :smiley:\");\n```\n![](https://i.imgur.com/VBiTPq5.png)\n\n### How to use them for reactions\n\nAdding unicode reactions is only possible by using the \"real\" reaction. It doesn't support tags like `:smiley:`.\n```java\nmessage.addReaction(\"üòÉ\"); // works\nmessage.addReaction(\":smiley:\"); // doesn't work\n```\n![](https://i.imgur.com/Wpp8PNz.png)\n\n## :woman_cartwheeling: Custom Emojis\n\n### What are custom emojis?\n\nCustom emojis are emojis that are created in a server. You can get all custom emojis the bot knows by using `DiscordApi#getCustomEmojis()`.\n\n![](https://i.imgur.com/5tb3Kxu.png)\n\n### How to use them in messages\n\nTo use custom emojis, you have to know its \"tag\", which has the format `<:name:id>`. You can get it by calling `CustomEmoji#getMentionTag()`:\n```java\nchannel.sendMessage(\"Hi! <:javacord:415465982715494402>\");\n```\n```java\nCustomEmoji emoji = ...;\nchannel.sendMessage(\"Hi! \" + emoji.getMentionTag());\n```\n\n### How to use them for reactions\n\nYou can either directly use the custom emoji object or use the tag without the `<:` `>` if you don't have access a custom emoji object (e.g., because it's from a different shard):\n\n```java\nCustomEmoji emoji = ...;\nmessage.addReaction(emoji);\n```\n```java\nmessage.addReaction(\"javacord:415465982715494402\");\n```\n\n### How to get the tag\n\nJust add a `\\` in front of the emoji and press `Enter`\n\n![](https://i.imgur.com/9L1WyFm.gif)\n\n![](https://i.imgur.com/4WTGo7F.png)\n\n## :crown: Javacord Emoji \"Hierarchy\"\n\nIn Javacord, all Emojis are a child of the `Emoji` interface:\n\n![](https://i.imgur.com/YtMKqXe.png)\n\n### What is a KnownCustomEmoji?\n\nKnown custom emojis are emojis that the bot knows because it's a member of the server with this emoji. A custom emoji can be unknown if someone adds a reaction with an unknown emoji for example. A `KnownCustomEmoji` has additional methods like `getServer()` or `updateName(String)`.\n\n## :ok_hand: Recommended libraries\n\nIf you are working a lot with Unicode emojis, it's recommended to use a library like [emoji-java](https://github.com/vdurmont/emoji-java). It enables you to do things like the following:\n```java\nmessage.addReaction(EmojiParser.parseToUnicode(\":thumbsup:\"));\n```","path":"/wiki/basic-tutorials/emojis-and-reactions.html","keywords":["create emoji","emoji creation","unicode emoji","custom emojis","delete emojis","emoji deletion","send emoji","use emoji","KnownCustomEmoji"]},{"title":"Gateway Intents","headers":[{"level":2,"title":"üìã List of Intents","slug":"list-of-intents"},{"level":2,"title":"üí° What Happens When I Disable Some Intents?","slug":"what-happens-when-i-disable-some-intents"},{"level":2,"title":"üëë Privileged Intents","slug":"privileged-intents"},{"level":2,"title":"‚ùóÔ∏è Notable Intents","slug":"notable-intents"},{"level":3,"title":"GUILD_PRESENCES","slug":"guild-presences"},{"level":3,"title":"GUILD_MEMBERS","slug":"guild-members"},{"level":2,"title":"‚öôÔ∏è Setting Intents","slug":"setting-intents"},{"level":3,"title":"Set All Non-Privileged Intents (Default)","slug":"set-all-non-privileged-intents-default"},{"level":3,"title":"Set All Non-Privileged Intents Except","slug":"set-all-non-privileged-intents-except"},{"level":3,"title":"Set All Intents","slug":"set-all-intents"},{"level":3,"title":"Set All Intents Except","slug":"set-all-intents-except"},{"level":3,"title":"Set Intents","slug":"set-intents"}],"content":"\n# Gateway Intents\n\nDiscord allows you to \"subscribe\" to specific groups of events.\nThese \"subscriptions\" are called intent.\nDisabling intents that are not required for your bot can significantly increase your bot's performance.\n\n## :clipboard: List of Intents\n\nBelow you can find a table with all intents supported by Discord.\n\n| Intent                     | Safe to Disable    | Privileged         |\n|----------------------------|--------------------|--------------------|\n| `GUILDS`                   | :x:                | :x:                |\n| `GUILD_MEMBERS`            | :heavy_check_mark: | :heavy_check_mark: |\n| `GUILD_BANS`               | :warning:\\*        | :x:                |\n| `GUILD_EMOJIS`             | :warning:\\*        | :x:                |\n| `GUILD_INTEGRATIONS`       | :heavy_check_mark: | :x:                |\n| `GUILD_WEBHOOKS`           | :heavy_check_mark: | :x:                |\n| `GUILD_INVITES`            | :heavy_check_mark: | :x:                |\n| `GUILD_VOICE_STATES`       | :warning:\\*        | :x:                |\n| `GUILD_PRESENCES`          | :heavy_check_mark: | :heavy_check_mark: |\n| `GUILD_MESSAGES`           | :heavy_check_mark: | :x:                |\n| `GUILD_MESSAGE_REACTIONS`  | :heavy_check_mark: | :x:                |\n| `GUILD_MESSAGE_TYPING`     | :heavy_check_mark: | :x:                |\n| `DIRECT_MESSAGES`          | :heavy_check_mark: | :x:                |\n| `DIRECT_MESSAGE_REACTIONS` | :heavy_check_mark: | :x:                |\n| `DIRECT_MESSAGE_TYPING`    | :heavy_check_mark: | :x:                |\n\n\\* Will most likely work, but needs further testing\n\n::: tip Good to know!\n*Guild* is a synonym for servers, commonly used in Discord's API.\nSee [Glossary](/wiki/basic-tutorials/glossary/).\n:::\n\n## :bulb: What Happens When I Disable Some Intents?\n\nWhen you disable some of the listed intents, Javacord will not fire events that belong to the intents and\nwill not update these specific parts of the cache.\n\nAt the moment, we don't have a list which events are affected by which intents (but it will come soon:tm:).\nHowever, most intents should be self-explanatory.\nE.g. when you disable the `DIRECT_MESSAGES` intent, your bot will not receive any private messages.\n\n## :crown: Privileged Intents\n\nSome intents are defined as \"privileged\" due to the sensitive nature of the data.\nTo use these intents, you have to go to your bot in the [Developer Portal](https://discord.com/developers/applications)\n(where you created bot) and manually enable the intents:\n\n![](./enable_privileged_intents.png)\n\nThere are some additionally restrictions for bots that are in over 100 servers:\n* Your bot must be verified\n* Your bot must be whitelisted to use this intents\n\nTake a look at the official article from Discord about this topic and how to verify your bot: \n[Bot Verification and Data Whitelisting](https://support.discord.com/hc/en-us/articles/360040720412).\n\n## :exclamation: Notable Intents\n\nThe following two intents are especially noteworthy: `GUILD_MEMBERS` and `GUILD_PRESENCES`.\nBesides being privileged, they have some special implications for Javacord:\n\n### `GUILD_PRESENCES`\n\nThis intent is required to get updates about a user's status (i.e., if they are online, what game they are playing, ...).\nAdditionally, without this intent it might take considerably longer to cache all users because of ratelimits \n(up to 10 minutes for shards with 1000 servers). \nIt is advised against setting `DiscordApiBuilder#setWaitForAllUsersOnStartup(true)` without this intent, unless absolutely necessary.\n\n### `GUILD_MEMBERS`\n\nThis intent is required to keep all users in Javacord's cache.\nWithout this intent, methods like `Server#getMembers()` or `DiscordApi#getCachedUsers()` will return empty collections.\nHowever, you will still be able to access users from objects like messages, e.g. `Message#getUserAuthor()` will still work.\n\n## :gear: Setting Intents\n\nJavacord allows you to specify intents in the `DiscordApiBuilder` prior to login.\nThere are many options to set intents.\nThe following example code shows the most common ones:\n\n### Set All Non-Privileged Intents (Default)\n\nThis method enables all non-privileged intents.\nThis is the default setting in Javacord.\n\n```java\nDiscordApi api = new DiscordApiBuilder()\n    .setToken(\"topc secret\")\n    .setAllNonPrivilegedIntents()\n    .login()\n    .join();\n```\n\n### Set All Non-Privileged Intents Except\n\nThis method enabled all non-privileged intents, except the given ones.\n\n```java\nDiscordApi api = new DiscordApiBuilder()\n    .setToken(\"topc secret\")\n    .setAllNonPrivilegedIntentsExcept(Intent.GUILD_WEBHOOKS)\n    .login()\n    .join();\n```\n\n### Set All Intents\n\nThis method enabled all intents.\n\n```java\nDiscordApi api = new DiscordApiBuilder()\n    .setToken(\"topc secret\")\n    .setAllIntents()\n    .login()\n    .join();\n```\n\n### Set All Intents Except\n\nThis method enabled all intents, except the given ones.\n\n```java\nDiscordApi api = new DiscordApiBuilder()\n    .setToken(\"topc secret\")\n    .setAllIntentsExcept(Intent.GUILD_PRESENCES, Intent.GUILD_WEBHOOKS)\n    .login()\n    .join();\n```\n\n### Set Intents\n\nThis method only enables the given intents.\n\n```java\nDiscordApi api = new DiscordApiBuilder()\n    .setToken(\"topc secret\")\n    .setIntents(Intent.GUILDS, Intent.DIRECT_MESSAGES)\n    .login()\n    .join();\n```\n","path":"/wiki/basic-tutorials/gateway-intents.html","keywords":["Intents"]},{"title":"Glossary","content":"\n# Glossary\n\nThis is a list with the most common Discord-related terms:\n* **`Guild`** - A synonym for `server`\n* **`Selfbot`** - A client account bot, usually logged in to a user's own account\n* **`Sharding`** - Splitting a bot into several independent `shards`, see [Sharding](/wiki/advanced-topics/sharding.html)\n* **`Token`** - Used to login instead of requiring a username + password\n* **`Embed`** - A \"fancy\" message, see [Embed FAQ](/wiki/basic-tutorials/embeds.html)\n* **`Ratelimit`** - Prevents you from spamming actions, see [Ratelimit FAQ](/wiki/advanced-topics/ratelimits.html)\n* **`Websocket`** - A [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) \"connection\" to Discord that receives events, see [Wikipedia](https://en.wikipedia.org/wiki/WebSocket)\n* **`Gateway`** - The address for the `websocket`\n* **`Rest` / `Rest Request`** - [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) is used to perform actions like sending messages. Rest Requests do not require an active websocket connection.\n* **`Activity`** - The text underneath the username, usually `Playing Xyz`\n* **`Rich Presence`** - A more detailed activity, see [Discord Docs](https://discordapp.com/developers/docs/rich-presence/getting-approved)","path":"/wiki/basic-tutorials/glossary.html","keywords":["Guild","Selfbot","Sharding","Token","Embed","Ratelimit","Websocket","Gateway","Rest Request","Activity","Rich Presence"]},{"title":"Interaction Commands aka. Slash Commands","headers":[{"level":2,"title":"üí° Creating a Command","slug":"creating-a-command"},{"level":3,"title":"üìî Notes on creating commands:","slug":"notes-on-creating-commands"},{"level":2,"title":"‚§µÔ∏è Get your commands","slug":"get-your-commands"},{"level":2,"title":"üî® Updating Commands","slug":"updating-commands"},{"level":2,"title":"‚úçÔ∏è Bulk overwriting commands","slug":"bulk-overwriting-commands"},{"level":2,"title":"üí¨ Responding to commands","slug":"responding-to-commands"},{"level":3,"title":"Sending followup messages","slug":"sending-followup-messages"},{"level":2,"title":"üëÆ Permissions","slug":"permissions"},{"level":3,"title":"Updating permissions of a single command","slug":"updating-permissions-of-a-single-command"},{"level":3,"title":"Updating multiple command permissions at once","slug":"updating-multiple-command-permissions-at-once"},{"level":2,"title":"‚ùóÔ∏è Limits","slug":"limits"},{"level":3,"title":"Registering a command","slug":"registering-a-command"},{"level":3,"title":"General","slug":"general"}],"content":"# Interaction Commands aka. Slash Commands\n::: tip INFO\nThere are a lot of convenient methods which aim to make your life easier with i.e., not\nbeing able to have an invalid configuration of your builder.\nTherefore, the following examples will only show the usage with the **convenient methods**.\n:::\n## :bulb: Creating a Command\n  \n::: tip INFO\nThere are 2 different types of Commands:\n- Global | Available for every Server once your Bot gets invited: Created with `createGlobal(DiscordApi)`.\n- Server | Only available on the specific Server: Created with `createForServer(Server)`.\n:::\n\nLet's get started with the most basic command, a **ping** command.\n``` java\nSlashCommand command = SlashCommand.with(\"ping\", \"Checks the functionality of this command\")\n    .createGlobal(api)\n    .join();\n```\n\nThat's all you have to do!\n\nLet's have a look at a more complex command which involves nearly all possibilities:\n\n``` java\nSlashCommand command =\n        SlashCommand.with(\"channel\", \"A command dedicated to channels\",\n            Arrays.asList(\n                SlashCommandOption.createWithOptions(SlashCommandOptionType.SUB_COMMAND_GROUP, \"edit\", \"Edits a channel\",\n                    Arrays.asList(\n                        SlashCommandOption.createWithOptions(SlashCommandOptionType.SUB_COMMAND, \"allow\", \"Allows a permission to a user for a channel\",\n                            Arrays.asList(\n                                SlashCommandOption.create(SlashCommandOptionType.CHANNEL, \"CHANNEL\", \"The channel to modify\", true),\n                                SlashCommandOption.create(SlashCommandOptionType.USER, \"USER\", \"The user which permissions should be changed\", true),\n                                SlashCommandOption.createWithChoices(SlashCommandOptionType.INTEGER, \"PERMISSION\", \"The permission to allow\", true,\n                                    Arrays.asList(\n                                        SlashCommandOptionChoice.create(\"MANAGE\", 0),\n                                        SlashCommandOptionChoice.create(\"SHOW\", 1)))\n        ))))))\n        .createGlobal(api)\n        .join();\n```\n\nLet that sink in first!\n\nWhat are we doing here?\n1. We create a base command called `channel`.\n2. It has a SUB_COMMAND_GROUP called `edit` which basically is just a folder where you can put your commands in.\n3. There's a SUB_COMMAND called `allow` which is our actual command. Therefore, our complete argument looks like `channel edit allow`.\n4. The SUB_COMMAND has 3 arguments:\n    1. The channel which should be edited.\n    2. The user which permissions should be changed.\n    3. A predefined list of available permissions the command executor can choose of.\n    \n![](https://i.imgur.com/Qb9lgqb.png)\n\n### :notebook_with_decorative_cover: Notes on creating commands:\n\n#### The `REQUIRED` attribute\nYou can only mark the **last** argument as being **not required**. This means it can be optionally set by the command executor.\nIn the above example you could i.e. set the `PERMISSIONS` argument to `false`.\n\n#### Command structure\nYour command has to follow these structures in order to be successfully created:\n\n::: details Command structure\n```\nVALID\n\ncommand\n|\n|__ subcommand\n|\n|__ subcommand\n\n----\n\ncommand\n|\n|__ subcommand-group\n    |\n    |__ subcommand\n|\n|__ subcommand-group\n    |\n    |__ subcommand\n\n\n-------\n\nINVALID\n\n\ncommand\n|\n|__ subcommand-group\n    |\n    |__ subcommand-group\n|\n|__ subcommand-group\n    |\n    |__ subcommand-group\n\n----\n\nINVALID\n\ncommand\n|\n|__ subcommand\n    |\n    |__ subcommand-group\n|\n|__ subcommand\n    |\n    |__ subcommand-group\n```\n:::\n## :arrow_heading_down: Get your commands\nAll global commands:\n``` java\nList<SlashCommand> commands = api.getGlobalSlashCommands().join();\n```\nAll commands only available on a single server:\n``` java\nServer server = ...;\nList<SlashCommand> commands = api.getServerSlashCommands(server).join();\n```\n::: warning\nGetting all commands from a server only contains the commands you have created on this specific server. \nTherefore, the returned list does not include any global command!\n:::\n\n## :hammer: Updating Commands\nWhen updating your commands you only have to include what you actually want to change. \nThe following updater will change the previous created command and change its base name from `channel` to `channels`. \n``` java\nSlashCommand updatedCommand =\n            new SlashCommandUpdater(commandId)\n                .setName(\"channels\")\n                .updateGlobal(api)\n                .join();\n```\n\n## :writing_hand: Bulk overwriting commands\nIf you have to update / create multiple commands at once it advised to use the batch updater to only have to do 1 request.\n``` java\nDiscordApi api = ...;\n\napi.bulkOverwriteGlobalSlashCommands(Arrays.asList(\n    new SlashCommandBuilder().setName(\"server\").setDescription(\"A command for the server\"),\n    new SlashCommandBuilder().setName(\"permission\").setDescription(\"A command for permissions\")))\n.join();\n```\n\n## :speech_balloon: Responding to commands\nThe following example responds to the previous created command to update the permissions of a channel\n``` java\napi.addSlashCommandCreateListener(event -> {\n    SlashCommandInteraction slashCommandInteraction = event.getSlashCommandInteraction();\n    ServerChannel channel = slashCommandInteraction.getFirstOptionChannelValue().orElse(null);\n    User user = slashCommandInteraction.getSecondOptionUserValue().orElse(null);\n    Integer permissionNumber = slashCommandInteraction.getThirdOptionIntValue().orElse(null);\n\n    // Update channel permissions...\n\n    slashCommandInteraction.createImmediateResponder()\n            .setContent(\"The channels permissions have been updated\")\n            .respond();\n});\n```\n\n::: tip INFO\nNote that you have to respond withing 3 seconds, or the command will fail. If you need longer than 3 seconds you have to \nrespond with `respondLater()` which allows you to respond within 15 minutes. \nIf you respond later you can send a followup message, described below.\n:::\n\n### Sending followup messages\nFollowup messages can be sent within 15 minutes after the command has been invoked. You can send as many followup messages as you want.\n``` java\napi.addSlashCommandCreateListener(event -> {\n    SlashCommandInteraction slashCommandInteraction = event.getSlashCommandInteraction();\n    slashCommandInteraction.respondLater().thenAccept(interactionOriginalResponseUpdater -> {\n        interactionOriginalResponseUpdater.setContent(\"You will receive the answer in a few minutes!\").update();\n\n        // time < 15 minutes\n        slashCommandInteraction.createFollowupMessageBuilder()\n                .setContent(\"Thank you for your patience, it took a while but the answer to the universe is 42\")\n                .send();\n    });\n});\n```\n\n## :policeman: Permissions\nPermissions exist to enable / disable the usage of your commands for certain things. These things may be:\n- Globally\n- Users\n- Roles\n\nAlready when you create a command you can define whether you want to enable it by default for all server once your bot gets invited.\nBy default, all commands you create are enabled for everyone. With the following code sniped you can disable your command for everyone.\nThis includes users, roles, server administrators and even server owners!\n``` java\nSlashCommand.with(\"ping\",\"Ping!\")\n    .setDefaultPermission(false)\n    .createGlobal(api)\n    .join();\n```\n### Updating permissions of a single command\nIf you want to update the permissions of your command, you have to use the Permissions Updater.\nThe following will disable the usage of a command for a user and a role:\n``` java\nlong USER_ID = ...;\nlong ROLE_ID = ...;\nlong COMMAND_ID = ...;\n\nnew ApplicationCommandPermissionsUpdater(server)\n    .setPermissions(Arrays.asList(\n        ApplicationCommandPermissions.create(USER_ID, ApplicationCommandPermissionType.USER, false),\n        ApplicationCommandPermissions.create(ROLE_ID, ApplicationCommandPermissionType.ROLE, false)))\n.update(COMMAND_ID)\n.join();\n```\n\n### Updating multiple command permissions at once\nIf updating multiple command permissions at once it is advised to batch overwrite them in order to do only 1 request.\nThe previous code snipped converted to the batch updater look like:\n``` java\nlong USER_ID = ...;\nlong ROLE_ID = ...;\nlong COMMAND_ID = ...;\n\nServerSlashCommandPermissionsBuilder builder1 = new ServerSlashCommandPermissionsBuilder(COMMAND_ID,\n        SlashCommandPermissions.create(USER_ID, SlashCommandPermissionType.USER, false));\nServerSlashCommandPermissionsBuilder builder2 = new ServerSlashCommandPermissionsBuilder(COMMAND_ID,\n        SlashCommandPermissions.create(ROLE_ID, SlashCommandPermissionType.ROLE, false));\n\napi.batchUpdateSlashCommandPermissions(server, Arrays.asList(builder1, builder2)).join();\n```\n\n## :exclamation: Limits\n### Registering a command\n- Server commands are specific to the server you specify when making them. Server commands are not available in DMs. Command names are unique per application within each scope (global and server). That means:\n- Your app cannot have two global commands with the same name\n- Your app cannot have two server commands within the same name on the same guild\n- Your app can have a global and guild command with the same name\n- Multiple apps can have commands with the same names\n### General\n- An app can have up to 100 top-level global commands with unique names\n- An app can have up to an additional 100 server commands per server\n- An app can have up to 25 subcommand groups on a top-level command\n- An app can have up to 25 subcommands within a subcommand group\n- Commands can have up to 25 options\n- Options can have up to 25 choices\n- Maximum of 4000 characters for combined name, description, and value properties for each command and its subcommands and groups\n- Limitations on nesting subcommands and groups\n- Global rate limit of 200 slash command creates per day per server\n","path":"/wiki/basic-tutorials/interactions/commands.html","keywords":["interaction","slash command"]},{"title":"Message Components","headers":[{"level":2,"title":"‚ùî What are components?","slug":"what-are-components"},{"level":2,"title":"üí° Sending a message with a component","slug":"sending-a-message-with-a-component"},{"level":2,"title":"üí¨ Responding to component interactions","slug":"responding-to-component-interactions"}],"content":"# Message Components\n## :grey_question: What are components?\nComponents are interactive elements like buttons or hidden elements like the ActionRow which use is for displaying the visible components. You can add them to a message and interact with users in a very convenient way.\nCurrently, the only interactive components available at the moment are buttons. They differ in style and behaviour(link redirect) seen in the picture below:\n![](https://support.discord.com/hc/article_attachments/1500019725621/buttons.png)\n## :bulb: Sending a message with a component\nSending a component with your message is a simple as that:\n``` java\nTextChannel channel = ...;\n\nnew MessageBuilder()\n    .setContent(\"Click on one of these Buttons!\")\n    .addComponents(\n        ActionRow.of(Button.success(\"success\", \"Send a message\"),\n            Button.danger(\"danger\", \"Delete this message\"),\n            Button.secondary(\"secondary\", \"Remind me after 5 minutes\")))\n    .send(channel);\n```\n![](https://i.imgur.com/5tMCePH.png)\n\nYou simply add a High Level component like an ActionRow which is a container for displaying your components.\nIn turn the ActionRow consist of the components you can interact with like Buttons.\n\nThis works for Select Menus as well:\n\n``` java\nTextChannel channel = ...;\n\nnew MessageBuilder()\n    .setContent(\"Select an option of this list!\")\n    .addComponents(\n        ActionRow.of(SelectMenu.create(\"options\", \"Click here to show the options\", 1, 1,\n            Arrays.asList(SelectMenuOption.create(\"Option One\", \"You selected Option One!\", \"Click here to select Option One\"),\n                SelectMenuOption.create(\"Option Two\", \"You selected Option Two!\", \"Click here to select Option Two\"),\n                SelectMenuOption.create(\"Option Three\", \"You selected Option Three!\", \"Click here to select Option Three\")))))\n    .send(channel);\n```\n![](https://i.imgur.com/bhcGjCN.png)\n\n![](https://i.imgur.com/ZlviGPe.png)\n\n## :speech_balloon: Responding to component interactions\nThe following code snipped shows how you can respond to the previously created example:\n``` java\napi.addMessageComponentCreateListener(event -> {\n    MessageComponentInteraction messageComponentInteraction = event.getMessageComponentInteraction();\n    String customId = messageComponentInteraction.getCustomId();\n\n    switch (customId) {\n        case \"success\":\n            messageComponentInteraction.createImmediateResponder()\n                    .setContent(\"You clicked a button!\")\n                    .respond();\n            break;\n        case \"danger\":\n            messageComponentInteraction.getMessage().ifPresent(Message::delete);\n            break;\n        case \"secondary\":\n            messageComponentInteraction.respondLater().thenAccept(interactionOriginalResponseUpdater -> {\n                //Code to respond after 5 minutes\n            });\n            break;\n        case \"options\":\n            messageComponentInteraction.createImmediateResponder()\n\t\t\t\t\t.setContent(\"You selected an option in a select menu!\")\n\t\t\t\t\t.respond();\n            break;\n    }\n});\n```\n*Note: once you receive a message component interaction you* ***must*** *respond with `createImmediateResponder` to send a message or `respondLater`, otherwise the interaction will fail.*","path":"/wiki/basic-tutorials/interactions/components.html","keywords":["interaction","component","button","actionrow","selectmenus"]},{"title":"Listeners","headers":[{"level":2,"title":"üë®‚Äçüîß Creating listeners","slug":"creating-listeners"},{"level":3,"title":"Inline Listeners","slug":"inline-listeners"},{"level":3,"title":"In their own class","slug":"in-their-own-class"},{"level":3,"title":"Before logging in","slug":"before-logging-in"},{"level":3,"title":"Object listeners","slug":"object-listeners"},{"level":2,"title":"üí£ Removing listeners","slug":"removing-listeners"},{"level":3,"title":"Using the returned ListenerManager","slug":"using-the-returned-listenermanager"},{"level":3,"title":"Using the removeListener(...) method","slug":"using-the-removelistener-method"}],"content":"\n# Listeners\n\n## :man_mechanic: Creating listeners\n\nCreating listeners is extremely easy in Javacord.\nYou can either use Java 8's lambda expressions to register listeners inline or just create a new class for them, if an inline listener would get too messy.\n\n### Inline Listeners\n\n```java\napi.addMessageCreateListener(event -> {\n    if (event.getMessageContent().equalsIgnoreCase(\"!ping\")) {\n        event.getChannel().sendMessage(\"Pong!\");\n    }\n});\n```\n\n### In their own class\n\n```java\napi.addListener(new MyListener());\n```\nand\n```java\npublic class MyListener implements MessageCreateListener {\n\n    @Override\n    public void onMessageCreate(MessageCreateEvent event) {\n        if (event.getMessageContent().equalsIgnoreCase(\"!ping\")) {\n            event.getChannel().sendMessage(\"Pong!\");\n        }\n    }\n\n}\n```\n\n### Before logging in\n\nSometimes it might be useful to add listeners before calling the `DiscordApiBuilder#login()` method.\n\n```java\nDiscordApi api = new DiscordApiBuilder()\n        // An inline listener\n        .addMessageCreateListener(event -> {\n            Message message = event.getMessage();\n            if (message.getContent().equalsIgnoreCase(\"!ping\")) {\n                event.getChannel().sendMessage(\"Pong!\");\n            }\n        })\n        .addServerBecomesAvailableListener(event -> {\n            System.out.println(\"Loaded \" + event.getServer().getName());\n        })\n        // A listener in their own class\n        .addListener(new MyListener())\n         // Alternative syntax that can be used for classes that require a DiscordApi parameter in their constructor\n        .addListener(MyListener::new)\n        .setToken(\"top secret\")\n        .setWaitForServersOnStartup(false)\n        .login()\n        .join();\n```\n\n> Note: In most cases, it's enough to add listeners after logging in\n\n### Object listeners\n\nAnother cool feature is the ability to attach listeners directly to objects. An example where this can be useful is, for example, reacting to reactions. The following code would delete the message if someone adds a :thumbsdown: reaction.\n\n```java\nmessage.addReactionAddListener(event -> {\n    if (event.getEmoji().equalsEmoji(\"üëé\")) {\n        event.deleteMessage();\n    }\n}).removeAfter(30, TimeUnit.MINUTES);\n```\n> Seems like the bot is very sensitive to criticism.\n\n## :bomb: Removing listeners\n\nThere are two ways to remove a listener:\n\n### Using the returned ListenerManager\n\nEvery time you register a listener, a `ListenerManager` is returned which can be used to unregister the listener:\n```java\nListenerManager<MessageCreateListener> listenerManager = api.addMessageCreateListener(event -> {\n    // Do stuff\n});\n\nlistenerManager.remove();\n```\n\nThis manager also has some utility methods. You can, for example, remove a listener after a given time, which can be useful for object listeners:\n```java\nmessage.addReactionAddListener(event -> {\n  // Do stuff\n}).removeAfter(30, TimeUnit.MINUTES);\n```\n\n### Using the `removeListener(...)` method\n\nYou can remove any listener using the `removeListener(...)` method:\n```java\nMyListener listener = new MyListener();\napi.addListener(listener);\n// ...\napi.removeListener(listener);\n```","path":"/wiki/basic-tutorials/listeners.html","keywords":["creating listeners","listener creation","ListenerManager","removeListener","remove listener"]},{"title":"Logger Configuration","headers":[{"level":2,"title":"ü•à Fallback Logger","slug":"fallback-logger"},{"level":2,"title":"ü•á Using a Proper Logging Framework","slug":"using-a-proper-logging-framework"},{"level":3,"title":"Adding a Logging Framework","slug":"adding-a-logging-framework"},{"level":3,"title":"Configure Your Logging Framework","slug":"configure-your-logging-framework"},{"level":3,"title":"Logging the Relevant Shard","slug":"logging-the-relevant-shard"}],"content":"\n# Logger Configuration\n\nLogging is an important tool to keep track of what is going on in your application. Javacord uses the [Log4j 2 API](https://logging.apache.org/log4j/2.x/manual/api.html), which allows you to use your favorite logging framework to log messages in your own code and have all logging messages end up in the same destination. In case you do not add your own logging framework, a fallback logger is used that logs to the console.  \nIf you want more control, add a proper logging framework that supports your needs and configure it accordingly. You can for example configure log messages on a per-class level, change log levels during runtime, or log to a file or database.\n\n## :2nd_place_medal: Fallback Logger\n\nJavacord's fallback logger is a simple Log4j logger which always logs `INFO` level and higher. It allows you to enable `DEBUG` and `TRACE` logging manually. As log levels are hierarchical, enabling `TRACE` will also implicitly enable `DEBUG`, and disabling `DEBUG` will also implicitly disable `TRACE`.\n\n```java\n// Enable debug logging\nFallbackLoggerConfiguration.setDebug(true);\n\n// Enable trace logging\nFallbackLoggerConfiguration.setTrace(true);\n```\n\nChanging the log level of the fallback logger only affects newly created loggers. Pre-existing loggers will not have their log level changed. So if you want to configure the fallback logger, you should do this as one of the first actions in your bot code. If you want to change log levels during runtime, you should use a proper logging framework like Log4j 2 Core or another library that supports this.\n\nAll fallback logger messages are printed to the standard output stream (`System.out`) and thus usually to your console. If you want to log to a file, database, or anything else, you should consider using a proper logging framework which allows you to configure this behavior.\n\nThis is how a log line from the fallback logger will look like:\n\n```log\n<time with date            ><level><logger name, usually the logging class              > <message            > <the thread context, here the shard number>\n2018-08-03 20:00:06.080+0200 DEBUG org.javacord.core.util.gateway.DiscordWebSocketAdapter Received HELLO packet {shard=0}\n```\n\n## :1st_place_medal: Using a Proper Logging Framework\n\n### Adding a Logging Framework\n\nAdding a logging framework of your choice is very straightforward. You can just add it as a dependency, and it will be detected by Log4j automatically. The following example adds Log4j 2 using Gradle:\n\n```groovy\ndependencies { runtimeOnly 'org.apache.logging.log4j:log4j-core:2.17.0' }\n```\n\nYou can also use an SLF4J compatible logging framework using `log4j-to-slf4j`. The following example adds Logback Classic using Gradle:\n\n```groovy\ndependencies {\n    runtimeOnly 'org.apache.logging.log4j:log4j-to-slf4j:2.17.0'\n    runtimeOnly 'ch.qos.logback:logback-classic:1.2.3'\n}\n```\n\n### Configure Your Logging Framework\n\n* **Log4j 2**: [Log4j configuration](https://logging.apache.org/log4j/2.x/manual/configuration.html)\n* **Logback Classic**: [Logback configuration](https://logback.qos.ch/manual/configuration.html)\n\n### Logging the Relevant Shard\n\nJavacord adds the relevant shard to each log message. The facility that stores this information has a different name depending on which logging framework you use. For Log4j 2, this is called Thread Context Map and can be added in a pattern layout with `%X{shard}`, or you can add the whole thread context map by using `%X`. For Logback Classic, it is called MDC and can be added with the same pattern expressions as for Log4j.","path":"/wiki/basic-tutorials/logger-config.html","keywords":["log4j","log4j2","slf4j","logback","logging","logger"]},{"title":"Using the MessageBuilder","headers":[{"level":2,"title":"üïµÔ∏è‚Äç‚ôÄÔ∏è Example","slug":"example"},{"level":2,"title":"üìç Allowed Mentions","slug":"allowed-mentions"}],"content":"\n# Using the MessageBuilder\n\nThe `MessageBuilder` class is a more powerful alternative to the `TextChannel#sendMessage(...)` method.\n\nIt can be used to construct more complex messages and supports some additional features that are not possible\nwith a simple `TextChannel#sendMessage(...)` call.\n\n## :female_detective: Example\n\nThe following code\n```java\nnew MessageBuilder()\n    .append(\"Look at these \")\n    .append(\"awesome\", MessageDecoration.BOLD, MessageDecoration.UNDERLINE)\n    .append(\" animal pictures! üòÉ\")\n    .appendCode(\"java\", \"System.out.println(\\\"Sweet!\\\");\")\n    .addAttachment(new File(\"C:/Users/Bastian/Pictures/kitten.jpg\"))\n    .addAttachment(new File(\"C:/Users/Bastian/Pictures/puppy.jpg\"))\n    .setEmbed(new EmbedBuilder()\n            .setTitle(\"WOW\")\n            .setDescription(\"Really cool pictures!\")\n            .setColor(Color.ORANGE))\n    .send(channel);\n```\nwill be displayed like this:\n\n ![](https://i.imgur.com/AP1cjDf.png)\n \n## :round_pushpin: Allowed Mentions\n\nThe allowed mentions object lets you control what should be mentioned (pinged) in a message if it contains mentions.\n\nThe following code will ping:\n- The user0\n- All mentioned roles in the message\n\nAnd will not ping:\n- @everyone and @here\n- The user1\n\n```java\nAllowedMentions allowedMentions = new AllowedMentionsBuilder()\n                .addUser(user0.getId())\n                .setMentionRoles(true)\n                .setMentionEveryoneAndHere(false)\n                .build();\n\n        new MessageBuilder()\n                .setAllowedMentions(allowedMentions)\n                .append(user0.getMentionTag())\n                .append(user1.getMentionTag())\n                .append(role.getMentionTag())\n                .append(role2.getMentionTag())\n                .append(\"@everyone\")\n                .send(channel);\n```\n\nIf you add a user to the mentions object and set `setMentionUsers(true)` it will ping every mentioned user. The same applies for `setMentionRoles(true)`\n","path":"/wiki/basic-tutorials/message-builder.html","keywords":["create messages","message creation","sendMessage"]},{"title":"Completable Futures","headers":[{"level":2,"title":"ü§î What the heck is a future?","slug":"what-the-heck-is-a-future"},{"level":2,"title":"üìñ Methods","slug":"methods"},{"level":3,"title":"join()","slug":"join"},{"level":3,"title":"thenAccept(...)","slug":"thenaccept"},{"level":3,"title":"exceptionally(...)","slug":"exceptionally"},{"level":3,"title":"thenCompose()","slug":"thencompose"},{"level":2,"title":"üìö Further Read","slug":"further-read"}],"content":"\n# Completable Futures\n\n::: warning\nThis tutorial assumes that you are familiar with lambda expressions.\nTake a look at the [lambda introduction](/wiki/essential-knowledge/lambdas/) first, if you are not!\n:::\n\nAs Javacord is heavily multithreaded, you must understand the concept of\n[Futures](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html) \nin general, as well as their most common implementation, the \n[CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html). \nThis little introduction gives you a quick overview of the basics you need to know in order to work with Futures.\n\n## :thinking: What the heck is a future?\n\nA future is basically a wrapper, that will contain a value in the future but might not contain it right now.\nThis is useful, if a method call requires some time and should not block the execution of your current code.\nYou can easily see the difference with a primitive speed comparison:\n\n```java\nlong currentTime = System.currentTimeMillis();\nchannel.sendMessage(\"Test 1\");\nchannel.sendMessage(\"Test 2\");\nchannel.sendMessage(\"Test 3\");\nchannel.sendMessage(\"Test 4\");\nchannel.sendMessage(\"Test 5\");\n// Prints \"4 ms\"\nSystem.out.println((System.currentTimeMillis() - currentTime) + \" ms\");\n```\n\n```java\nlong currentTime = System.currentTimeMillis();\nchannel.sendMessage(\"Test 1\").join();\nchannel.sendMessage(\"Test 2\").join();\nchannel.sendMessage(\"Test 3\").join();\nchannel.sendMessage(\"Test 4\").join();\nchannel.sendMessage(\"Test 5\").join();\n// Prints \"894 ms\"\nSystem.out.println((System.currentTimeMillis() - currentTime) + \" ms\");\n```\n\n::: tip\n`join()` blocks the current thread until the method finished. This will be explained later.\n:::\n\n## :open_book: Methods\n\n### join()\n\nThe `join` method blocks the current thread until the method finished.\nIt returns the method's result or throws a `CompletionException` if anything failed.\n\nThe following example would create a new text channel in a given `server` and sends a message directly afterwards.\n```java\n// Create the channel\nServerTextChannel channel = new ServerTextChannelBuilder(server)\n    .setName(\"new-channel\")\n    .create()\n    .join();\n// Send a message in the new channel\nMessage message = channel.sendMessage(\"First!\").join();\n// Adds an reaction to the message. Even though this method doesn't return anything,\n// join() ensures, that an exception is thrown in case something went wrong\nmessage.addReaction(\"üëç\").join();\n```\n\n::: danger\nYou should avoid `join()` for methods which will be called frequently.\n:::\n\n::: tip\nWhile `join()` can become a performance issue when you call it very frequently, it is very convenient to use and easy to understand.\nIf you are new to programming and just want to get your first bot working, this is a good method to start with.\n\nOnce you gathered more experience, we highly advise against using `join` as it negatively impacts your bot's performance!\n:::\n\n### thenAccept(...)\n\nThe `thenAccept` method accepts a `Consumer`, that consumes the result of the method and is executed asynchronously.\nIt is the method you usually want to use most of the time.\n\nThe following example would create a new text channel in a given `server` and send a message directly afterwards.\n```java\nnew ServerTextChannelBuilder(server)\n    .setName(\"new-channel\")\n    .create()\n    .thenAccept(channel -> {\n        channel.sendMessage(\"First!\").thenAccept(message -> {\n            message.addReaction(\"üëç\");\n        });\n    });\n```\n\n::: danger\nThe example code above has a major problem: Any exception that might occur will be completely ignored.\nThis makes it very hard to find bugs.\n\nFor example, if your bot doesn't have the permissions to create a new channel, it will just fail silently.\n:::\n\n### exceptionally(...)\n\nThe `exceptionally` method accepts a `Function` as parameter, which consumes possible exceptions and returns a fallback value.\n\nThe following example would create a new text channel in a given `server` and send a message directly afterwards.\nIf something fails (e.g., if the bot isn't allowed to create a text channel in the server), it will log an exception.\n\n```java\nnew ServerTextChannelBuilder(server)\n    .setName(\"new-channel\")\n    .create()\n    .thenAccept(channel -> {\n        channel.sendMessage(\"First!\").thenAccept(message -> {\n            message.addReaction(\"üëç\").exceptionally(e -> {\n                e.printStackTrace(); // Adding the reaction failed\n                return null;\n            });\n        }).exceptionally(e -> {\n            e.printStackTrace(); // Message sending failed\n            return null;\n        });\n    }).exceptionally(e -> {\n        e.printStackTrace(); // Channel creation failed    \n        return null;\n    });\n```\n\nWow! This looks ugly ü§Æ.\nBut worry not! There are many options to improve this code!\n\nTo make things simpler for you, Javacord has the `ExceptionLogger` class, which can be used here.\nIt logs every exception you didn't catch manually.\n\n```java\nnew ServerTextChannelBuilder(server)\n    .setName(\"new-channel\")\n    .create()\n    .thenAccept(channel -> {\n        channel.sendMessage(\"First!\").thenAccept(message -> {\n            message.addReaction(\"üëç\").exceptionally(ExceptionLogger.get());\n        }).exceptionally(ExceptionLogger.get());\n    }).exceptionally(ExceptionLogger.get());\n```\n\nOkay! This is at least a little better, but still not really perfect :thinking:.\n\n### thenCompose()\n\nThe `thenCompose` methods allows you to chain futures.\nIt takes a [Function](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html) as parameter, that\nconsumes the future's value and expects a new future to be returned.\n\nThe example to create a text channel can now be written like this:\n```java\nnew ServerTextChannelBuilder(server)\n        .setName(\"new-channel\")\n        .create() \n        .thenCompose(channel -> channel.sendMessage(\"First!\"))\n        .thenCompose(message -> message.addReaction(\"üëç\"))\n        .exceptionally(ExceptionLogger.get());\n```\n\nFinally :tada:! Now we only need a single `exceptionally(...)` call at the end.\nWe also got rid of the nested callbacks (usually referred to as \"callback hell\").\n\nFor better understanding, here's the example with comments that tell you the type at each line:\n```java\nnew ServerTextChannelBuilder(server) // ServerTextChannelBuilder\n        .setName(\"new-channel\") // ServerTextChannelBuilder\n        .create() // CompletableFuture<ServerTextChannel>\n        .thenCompose(channel -> channel.sendMessage(\"First!\")) // CompletableFuture<Message>\n        .thenCompose(message -> message.addReaction(\"üëç\")) // CompletableFuture<Void>\n        .exceptionally(ExceptionLogger.get()); // CompletableFuture<Void>\n```\n\n## :books: Further Read\n\nThis tutorial only focuses on the absolute basics.\nFor a more detailed introduction to CompletableFutures, you can take a look at\n[this tutorial](https://www.callicoder.com/java-8-completablefuture-tutorial/).\n\nYou should also take a look at the JavaDoc for a complete list of methods: [CompletableFuture JavaDoc](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html).\n","path":"/wiki/essential-knowledge/completable-futures.html","keywords":["CompletableFuture","exceptionally","ExceptionLogger","join","thenAcceptAsync"]},{"title":"Lambdas","headers":[{"level":2,"title":"üìö Further Read","slug":"further-read"}],"content":"\n# Lambdas\n\nLambdas are used to implement [functional interfaces](https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html).\nSimply said, functional interfaces are interfaces with a single method definition.\nAll listeners in Javacord are functional interfaces and look like this internally (simplified):\n\n```java\n@FunctionalInterface\npublic interface MessageCreateListener {\n    void onMessageCreate(MessageCreateEvent event);\n}\n```\n\nBefore Java 8, you would have implemented this kind of listener as an [anonymous class](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html), which would look like this:\n\n```java\napi.addMessageCreateListener(new MessageCreateListener() {\n    @Override\n    public void onMessageCreate(MessageCreateEvent event) {\n        // Do stuff\n        event.pinMessage();\n    }\n});\n```\n\nIn Java 8, this can be replaced with a lambda expression, which does exactly the same thing, but in a more readable fashion. \nThe method parameter (in this case `event`) is written in front of the `->` arrow, and the method body is written after it.\n\n```java\napi.addMessageCreateListener(event -> {\n    // Do stuff\n    event.pinMessage();\n});\n```\n\n::: tip\nIf the method has more than one parameter, it would look like this: \n```java\n(param1, param2) -> { ... }\n```\n:::\n\nThere's even a shorter version: If you are only executing one statement, you can get rid of the `{ }` brackets as well:\n```java\napi.addMessageCreateListener(event -> event.pinMessage());\n```\n\nHowever, the above method can be shortened even more, by replacing the lambda expression with a so called \"[method reference](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html)\".\n```java\napi.addMessageCreateListener(MessageEvent::pinMessage);\n```\n\nThere are also plenty classes in Java 8, that make use of lambda expressions.\nOne example would be the Optional class, which is explained [here](/wiki/essential-knowledge/optionals/).\n\n## :books: Further Read\n\nThis tutorial only focuses on the absolute basics.\nFor an in-depth introduction to lambda expressions, you can take a look at\n[Oracle's article about lambda expressions](https://www.oracle.com/technical-resources/articles/java/architect-lambdas-part1.html).\n\n","path":"/wiki/essential-knowledge/lambdas.html","keywords":["lambdas"]},{"title":"Optionals","headers":[{"level":2,"title":"üí™ Motivation","slug":"motivation"},{"level":3,"title":"The old way of doing it","slug":"the-old-way-of-doing-it"},{"level":3,"title":"The new way of doing it","slug":"the-new-way-of-doing-it"},{"level":2,"title":"üìñ Methods","slug":"methods"},{"level":3,"title":"get()","slug":"get"},{"level":3,"title":"isPresent()","slug":"ispresent"},{"level":3,"title":"orElse(...)","slug":"orelse"},{"level":3,"title":"ifPresent(...)","slug":"ifpresent"},{"level":3,"title":"filter(...)","slug":"filter"},{"level":3,"title":"map(...)","slug":"map"},{"level":3,"title":"flatMap(...)","slug":"flatmap"},{"level":2,"title":"üìö Further Read","slug":"further-read"}],"content":"\n# Optionals\n\n::: warning\nThis tutorial assumes that you are familiar with lambda expressions.\nTake a look at the [lambda introduction](/wiki/essential-knowledge/lambdas/) first, if you are not!\n:::\n\n## :muscle: Motivation\n\nThe Optional class is widely used in Javacord.\nBasically, every method that might return a `null` value will return an Optional in Javacord instead.\nOptionals help you to avoid `NullPointerExceptions` and make it very clear if a method may not have a result.\nHere's a small example:\n\n### The old way of doing it\n\n```java\nUser user = api.getCachedUserById(123L);\nif (user != null) {\n  user.sendMessage(\"Hi!\");\n}\n```\n\n### The new way of doing it\n\n```java\napi.getCachedUserById(123L).ifPresent(user -> \n  user.sendMessage(\"Hi!\")\n);\n```\n\nYou can imagine an `Optional` like a box :package: that may or may not contain a value.\nBefore accessing this value, you have to \"unpack\" this box first.\n\n## :open_book: Methods\n\nThe Optional class has many useful methods which can all be found in the [JavaDocs](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html).\nThis tutorial gives a short introduction to the most common ones.\n\n### get()\n\nThe `get` method returns the value of the Optional or throws a `NoSuchElementException` if it does not contain a value.\n\n```java\nTextChannel channel = api.getTextChannelById(123L).get();\nchannel.sendMessage(\"Hi\");\n```\n\n::: danger\nYou should never use this method blindly but only if you are **100%** sure the optional contains a value.\n\nEvery time you use this method carelessly, a kitten dies :scream_cat:!\nTrue story.\n:::\n\n### isPresent()\n\nThe `isPresent` methods checks, if the Optional contains a value.\n\n```java\nOptional<TextChannel> channel = api.getTextChannelById(123L);\nif (channel.isPresent()) {\n  // A text channel with the id 123 exists. It's safe to call #get() now\n  channel.get().sendMessage(\"Hi\");\n}\n```\n\n### orElse(...)\n\nThe `orElse` methods returns the value of the Optional if it is present. Otherwise, it returns the given default value.\n\n```java\n// The user may not have a nickname on the given server. \n// In this case, we use the user's \"regular\" name.\nString displayName = user.getNickname(server).orElse(user.getName());\n```\nThe example above is (mostly) equivalent to the example below but much more concise.\n```java\nString displayName = \"\";\nOptional<String> nickname = user.getNickname(server);\nif (nickname.isPresent()) {\n  displayName = nickname.get();\n} else {\n  displayName = user.getName();\n}\n```\n\n::: tip\nIn this case you can just use `user.getDisplayName(server)` instead.\n:::\n\n### ifPresent(...)\n\nThe `ifPresent` method is very similar to an `if (value != null) { ... }` check. \nIt takes a [Consumer](https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html) as it's argument.\nThis consumer is called if the Optional contains a value.\nTogether with lambda expressions this can be a very handy method.\n\n```java\napi.getTextChannelById(123L).ifPresent(channel -> {\n  channel.sendMessage(\"Hi!\");\n});\n```\nThe example above is (mostly) equivalent to the example below but more concise.\n```java\nOptional<TextChannel> channel = api.getTextChannelById(123L);\nif (channel.isPresent()) {\n  channel.get().sendMessage(\"Hi!\");\n}\n```\n\n### filter(...)\n\nThe `filter` method filters the Optional for a given criteria.\n\n```java\nOptional<User> botUser = api.getCachedUserById(123L).filter(User::isBot);\n```\nThe example above is equivalent to the example below but more concise.\n```java\nOptional<User> user = api.getCachedUserById(123L);\nOptional<User> botUser;\nif (user.isPresent() && user.get().isBot()) {\n  botUser = user;\n} else {\n  botUser = Optional.empty();\n}\n```\n\n### map(...)\n\nThe `map` method \"converts\" the type of an Optional.\nThis is useful, if the type of an Optional does not contain the final value you need.\n\nThe following example gets the name of the bots current activity (the \"Playing xyz\" status) or \"None\" if the bot has no current activity.\n\n```java\nString activityName = api.getYourself().getActivity().map(Activity::getName).orElse(\"None\");\n```\nFor better understanding, here's the exact same code but with the types as comments:\n```java\nString activityName =  api.getYourself() // User\n        .getActivity() // Optional<Activity>\n        .map(Activity::getName) // Optional<String>\n        .orElse(\"None\"); // String\n```\n\n### flatMap(...)\n\nThe `flatMap` method if very similar to the `map` methods.\nIt is used to map values that itself are Optionals to prevent Optional nesting (a \"box in a box\").\n\n```java\nString activityName = api.getCachedUserById(123L) // Optional<User>\n        .flatMap(User::getActivity) // Optional<Activity>\n        .map(Activity::getName) // Optional<String>\n        .orElse(\"None\"); // String\n```\n\nWithout `flatMap`, the code would look like this:\n```java\nString activityName = api.getCachedUserById(123L) // Optional<User>\n        .map(User::getActivity) // Optional<Optional<Activity>>\n        .filter(Optional::isPresent) // Optional<Optional<Activity>>\n        .map(Optional::get) // Optional<Activity>\n        .map(Activity::getName) // Optional<String>\n        .orElse(\"None\"); // String\n```\n\n## :books: Further Read\n\nThis tutorial only focuses on the absolute basics.\nFor an in-depth introduction to Optionals, you can take a look at\n[Oracle's article about optionals](https://www.oracle.com/technical-resources/articles/java/java8-optional.html).\n\n","path":"/wiki/essential-knowledge/optionals.html","keywords":[null,"ifPresent","isPresent","orElse"]},{"title":"Introduction","headers":[{"level":2,"title":"üìö Structure of the wiki","slug":"structure-of-the-wiki"},{"level":2,"title":"ü§ù Support","slug":"support"}],"content":"\n# Introduction\n\nWelcome to the Javacord wiki! :wave:\n\nThis wiki will help you to get started with your first Discord bot as fast as possible.\n\n## :books: Structure of the wiki\n\nThe wiki is divided into four groups:\n* **Getting Started** focuses on teaching you how to setup up everything to get the most basic bot working.\n* **Basic tutorials** contains articles about various concepts and classes of Javacord. Take a look at the headlines of each article and decide yourself, if it is relevant for you.\n* **Advanced Topics** focuses on some more advanced topics that are not strictly necessary to start working with Javacord, but might become handy later on.\n* **Essential Knowledge** teaches you the most important Java features/classes that you should know to comfortably work with Javacord. If you already have decent Java knowledge, you can skip this completely.\n\n\n## :handshake: Support\n\nWhile the wiki is great and covers many aspects of Javacord, we highly recommended you to join our Discord server if you have any questions:\n* Join the **[Javacord server](https://discord.gg/0qJ2jjyneLEgG7y3)** (Invite code: `0qJ2jjyneLEgG7y3`)\n\n","path":"/wiki/","keywords":[]},{"title":"Creating a Bot Account","headers":[{"level":2,"title":"üí° Create a bot and get its token","slug":"create-a-bot-and-get-its-token"},{"level":2,"title":"‚ûï How to add a bot to your server","slug":"how-to-add-a-bot-to-your-server"},{"level":3,"title":"Use Javacord to create the invite link","slug":"use-javacord-to-create-the-invite-link"},{"level":3,"title":"Create the invite link manually","slug":"create-the-invite-link-manually"},{"level":2,"title":"üôã‚Äç‚ôÇ Use the invite link","slug":"use-the-invite-link"}],"content":"\n# Creating a Bot Account\n\nAfter you added Javacord as a dependency with your favorite build manager, you should now create a bot account on the Discord website.\nThis article will guide you through the process.\n\n## :bulb: Create a bot and get its token\n\n#### **1.** Open [https://discord.com/developers/applications/me](https://discordapp.com/developers/applications/me) and click on \"Create an application\".\n\n![](./create-application.png)\n\n#### **2.** Switch to `Bot`\n\n::: tip\nIf you want to, you can rename your application first\n::: \n\n![](./click-bot.png)\n\n#### **3.** Click on `Add bot` and confirm the popup\n\n![](./add-bot.png)\n![](./confirm.png)\n\n#### **4.** Copy the bot's token. In this case the token would be `NDc[...]pCs`. You can just click on `Copy`.\n\n::: danger\nThis token is used to login your bot. Keep it secret!\n:::\n\n![](./copy-token.png)\n\n#### **5.** If you want to, you can change the bot's name and avatar on this page, too.\n\n## :heavy_plus_sign: How to add a bot to your server\n\nBots cannot join a server on their own like normal Discord users can.\nInstead, the owner of a server has to invite the bot using a so called `Invite Link`.\nThere are multiple ways to create the invite link:\n\n### Use Javacord to create the invite link\n\nThe easiest way to obtain an invite link for your bot is by letting Javacord do it for you.\nSimply execute the following code, and it will print the invite link to your console:\n\n```java\nDiscordApi api = new DiscordApiBuilder().setToken(\"your token\").login().join();\nSystem.out.println(api.createBotInvite());\n```\n\nIf you don't have Javacord setup yet, you can also create the invite link manually.\n\n### Create the invite link manually\n\n#### Get the client id\n\nIn order to add a bot to your server you need its client id.\n\nYou can get your client id from the [same page](https://discord.com/developers/applications/me) where you created it.\n\n![](./get-client-id.png)\n\nWith this id you can create an invite link for your bot.\n\nIf you are the owner or admin of the server, you can use this link to add your bot to your server. Otherwise, you have to give the link to the server owner/admins and ask them to add your bot.\n\n::: tip\nUnlike the token, you don't have to keep your client id secret\n:::\n\n#### Create the url\n\nJust use the following link and replace `123456789` with your own client id.\n\n**https://discord.com/api/oauth2/authorize?client_id=123456789&scope=bot&permissions=0**\n\nYou can calculate the permissions (in the link above it's the `0`) on the page where you created the bot:\n\n![](./calculate-permissions.png)\n\n## :raising_hand_man: Use the invite link\n\nYou can now open the link and add the bot to your server:\n\n![](./use-invite-link.png)\n\n::: tip\nOnly the owner and admins of a server can invite bots. If you do not own a server yet, it is recommended to create one for testing.\n::: ","path":"/wiki/getting-started/creating-a-bot-account.html","keywords":["bot creation","get token","add bot","bot invite link"]},{"title":"Download / Installation","headers":[{"level":2,"title":"üì¶ Javacord Dependency","slug":"javacord-dependency"},{"level":3,"title":"Gradle","slug":"gradle"},{"level":3,"title":"Maven","slug":"maven"},{"level":3,"title":"Sbt","slug":"sbt"},{"level":3,"title":"Gradle","slug":"gradle-2"},{"level":3,"title":"Maven","slug":"maven-2"},{"level":3,"title":"Sbt","slug":"sbt-2"},{"level":2,"title":"üìù Optional Logger Dependency","slug":"optional-logger-dependency"},{"level":3,"title":"Gradle","slug":"gradle-3"},{"level":3,"title":"Maven","slug":"maven-3"},{"level":3,"title":"Sbt","slug":"sbt-3"}],"content":"\n# Download / Installation\n\nThe recommended way to get Javacord is to use a build manager, like Gradle or Maven.  \nIf you are not familiar with build managers, you can follow one of the beginner ide setup guides (see navigation) or download Javacord directly from [GitHub](https://github.com/Javacord/Javacord/releases/latest).\n\n## :package: Javacord Dependency\n\n<LatestVersionInfo/>\n\n### Gradle\n\n```groovy\nrepositories { mavenCentral() }\ndependencies { implementation 'org.javacord:javacord:$latest-version' }\n```\n\n### Maven\n\n```xml\n<dependency>\n    <groupId>org.javacord</groupId>\n    <artifactId>javacord</artifactId>\n    <version>$latest-version</version>\n    <type>pom</type>\n</dependency>\n```\n\n### Sbt\n\n```scala\nlibraryDependencies ++= Seq(\"org.javacord\" % \"javacord\" % \"$latest-version\")\n```\n\n::: details Click to view snapshot repositories\n\nSnapshots are automatically deployed from the [development](https://github.com/Javacord/Javacord/tree/development) branch.\n\n### Gradle\n\n```groovy\nrepositories { \n  maven {\n    url \"https://oss.sonatype.org/content/repositories/snapshots/\"\n  }\n}\ndependencies { \n  implementation 'org.javacord:javacord:$latest-snapshot-version' \n}\n```\n\n### Maven\n\n```xml\n<repository>\n    <id>snapshots-repo</id>\n    <url>https://oss.sonatype.org/content/repositories/snapshots/</url>\n</repository>\n```\n```xml\n<dependency>\n    <groupId>org.javacord</groupId>\n    <artifactId>javacord</artifactId>\n    <version>$latest-snapshot-version</version>\n    <type>pom</type>\n</dependency>\n```\n\n### Sbt\n\n```scala\nresolvers += \"snapshots-repo\" at \"https://oss.sonatype.org/content/repositories/snapshots/\"\nlibraryDependencies ++= Seq(\"org.javacord\" % \"javacord\" % \"$latest-snapshot-version\")\n```\n:::\n\n\n## :memo: Optional Logger Dependency\n\nIn addition to Javacord, it is also recommended to install a Log4j-2-compatible logging framework.\nA logging framework can be used to provide a more sophisticated logging experience with being able to configure log format, log targets (console, file, database, Discord direct message, ...), log levels per class, and much more.\n\nFor example, Log4j Core:\n\n### Gradle\n\n```groovy\ndependencies { runtimeOnly 'org.apache.logging.log4j:log4j-core:2.17.0' }\n```\n\n### Maven\n\n```xml\n<dependency>\n    <groupId>org.apache.logging.log4j</groupId>\n    <artifactId>log4j-core</artifactId>\n    <version>2.17.0</version>\n</dependency>\n```\n\n### Sbt\n\n```scala\nlibraryDependencies ++= Seq(\"org.apache.logging.log4j\" % \"log4j-core\" % \"2.17.0\")\n```\n\nTake a look at the [logger configuration](/wiki/basic-tutorials/logger-config/) wiki article for further information.","path":"/wiki/getting-started/download-installation.html","keywords":["download and installation","maven","gradle"]},{"title":"Eclipse + Maven","headers":[{"level":2,"title":"üîß Setup","slug":"setup"},{"level":2,"title":"üèÉ‚Äç‚ôÄ Run the code","slug":"run-the-code"}],"content":"# Eclipse + Maven\n\nThis tutorial provides a beginner-friendly click by click guide to set up Javacord with Eclipse and Maven.\nIf you are already familiar with Eclipse and Maven, you can just see the artifact locations at [Download / Installation](/wiki/getting-started/download-installation.md).\n\n::: tip Info\nWe recommend to use [Intellij + Gradle](./intellij-gradle.md) unless you already have experience with one of the other IDEs or build managers.\n::: \n\n## :wrench: Setup\n\n#### **1.** Start Eclipse\n\n#### **2.** Create a new project (`File` -> `New` -> `Project`)\n\n![](https://i.imgur.com/hYeYxen.png)\n\n#### **3.** Select `Maven Project`\n\n#### **4.** Click `Next`\n\n![](https://i.imgur.com/CeHy9HK.png)\n\n#### **5.** Check `Create a simple project`\n\n#### **6.** Click `Next`\n\n![](https://i.imgur.com/xxbGmr6.png)\n\n#### **7.** Enter a group id (e.g. `com.github.yourname`)\n\n#### **8.** Enter an artifact id (e.g. `myfirstbot`)\n\n#### **9.** Click `Finish`\n\n![](https://i.imgur.com/JSV9yrl.png)\n\n#### **10.** Double click on the `pom.xml` file\n\n![](https://i.imgur.com/NCAALIt.png)\n\n#### **11.** Select `pom.xml`\n\n![](https://i.imgur.com/kbdtiLJ.png)\n\n#### **12.** Now you have to add Javacord as a dependency by editing the pom.xml file. Your file should now look like this:\n\n<LatestVersionInfo/>\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>your.package.name</groupId>\n    <artifactId>myfirstbot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.javacord</groupId>\n            <artifactId>javacord</artifactId>\n            <version>$latest-version</version>\n            <type>pom</type>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n#### **13.** Create a new package inside the `src/main/java` folder\n\n![](https://i.imgur.com/Z1QNuQf.png)\n![](https://i.imgur.com/RKJc0yU.png)\n\n#### **14.** Create a new class inside this package\n\n![](https://i.imgur.com/eUmumlz.png)\n![](https://i.imgur.com/GsPFaag.png)\n\n#### **15.**  Save the project (you should do this from time to time)\n\n![](https://i.imgur.com/Ht5UT8S.png)\n\n#### **16.** Now you can start coding! Example code:\n\n```java\npackage com.github.yourname.myfirstbot;\n\nimport org.javacord.api.DiscordApi;\nimport org.javacord.api.DiscordApiBuilder;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        // Insert your bot's token here\n        String token = \"your token\";\n\n        DiscordApi api = new DiscordApiBuilder().setToken(token).login().join();\n\n        // Add a listener which answers with \"Pong!\" if someone writes \"!ping\"\n        api.addMessageCreateListener(event -> {\n            if (event.getMessageContent().equalsIgnoreCase(\"!ping\")) {\n                event.getChannel().sendMessage(\"Pong!\");\n            }\n        });\n\n        // Print the invite url of your bot\n        System.out.println(\"You can invite the bot by using the following url: \" + api.createBotInvite());\n    }\n\n}\n```\n\n## :running_woman: Run the code\n\nYou can run your code by clicking on the small green arrow\n![](https://i.imgur.com/rsIHH9M.png)","path":"/wiki/getting-started/setup/eclipse-maven.html","keywords":[]},{"title":"IntelliJ + Gradle","headers":[{"level":2,"title":"üîß Setup","slug":"setup"},{"level":2,"title":"üèÉ‚Äç‚ôÄ Run the code","slug":"run-the-code"}],"content":"# IntelliJ + Gradle\n\nThis tutorial provides a beginner-friendly click by click guide to set up Javacord with Intellij and Gradle.\nIf you are already familiar with IntelliJ and Gradle, you can just see the artifact locations at [Download / Installation](/wiki/getting-started/download-installation.md).\n\n## :wrench: Setup\n\n#### **1.** Start IntelliJ\n\n#### **2.** Create a new project (`File` -> `New` -> `Project`)\n\n![](./img-intellij-gradle/create-project.png)\n\n#### **3.** Select `Gradle`\n\n#### **4.** Make sure to select an SDK which is 1.8 (or greater)\n\n#### **5.** Click `Next`\n\n![](./img-intellij-gradle/select-gradle.png)\n\n#### **6.** Enter a group id (e.g. `com.github.yourname`)\n\nYou can choose whatever you want\n\n#### **7.** Enter an artifact id (e.g. `myfirstbot`)\n\nYou can choose whatever you want\n\n#### **8.** Click `Next`\n\n![](./img-intellij-gradle/new-project.png)\n\n#### **9.** Check `Use auto-import`\n\n#### **10.** Click `Next`\n\n![](./img-intellij-gradle/new-project-2.png)\n\n#### **11.** Click `Finish`\n\n![](./img-intellij-gradle/new-project-3.png)\n\n#### **12.** Locate the `build.gradle` file and open it\n\n![](./img-intellij-gradle/after-finished.png)\n\n#### **12.** Add the Javacord dependency. Your `build.gradle` file should now look like this\n\n<LatestVersionInfo/>\n\n```groovy\nplugins {\n    id 'java'\n}\n\ngroup 'com.github.yourname'\nversion '1.0-SNAPSHOT'\n\nsourceCompatibility = 1.8\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.javacord:javacord:$latest-version'\n}\n```\n\n#### **13.** Create a new package in the `src/main/java` folder\n\n![](./img-intellij-gradle/new-package.png)\n![](./img-intellij-gradle/new-package-2.png)\n\n#### **14.** Create a new class inside this package\n\n![](./img-intellij-gradle/new-class.png)\n![](./img-intellij-gradle/new-class-2.png)\n\n#### **15.** You can now start coding!\n\nExample code:\n```java\npackage com.github.yourname;\n\nimport org.javacord.api.DiscordApi;\nimport org.javacord.api.DiscordApiBuilder;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        // Insert your bot's token here\n        String token = \"your token\";\n\n        DiscordApi api = new DiscordApiBuilder().setToken(token).login().join();\n\n        // Add a listener which answers with \"Pong!\" if someone writes \"!ping\"\n        api.addMessageCreateListener(event -> {\n            if (event.getMessageContent().equalsIgnoreCase(\"!ping\")) {\n                event.getChannel().sendMessage(\"Pong!\");\n            }\n        });\n\n        // Print the invite url of your bot\n        System.out.println(\"You can invite the bot by using the following url: \" + api.createBotInvite());\n    }\n\n}\n```\n\n## :running_woman: Run the code\n\nYou can run your code by clicking on the small green arrow\n![](./img-intellij-gradle/run-the-bot.png)","path":"/wiki/getting-started/setup/intellij-gradle.html","keywords":[]},{"title":"IntelliJ + Maven","headers":[{"level":2,"title":"üîß Setup","slug":"setup"},{"level":2,"title":"üèÉ‚Äç‚ôÄ Run the code","slug":"run-the-code"},{"level":2,"title":"üöß Possible problems","slug":"possible-problems"}],"content":"# IntelliJ + Maven\n\nThis tutorial provides a beginner-friendly click by click guide to set up Javacord with Intellij and Maven.\nIf you are already familiar with IntelliJ and Maven, you can just see the artifact locations at [Download / Installation](/wiki/getting-started/download-installation.md).\n\n::: tip Info\nWe recommend to use [Intellij + Gradle](./intellij-gradle.md) unless you already have experience with one of the other IDEs or build managers.\n::: \n\n## :wrench: Setup\n\n#### **1.** Start IntelliJ\n\n#### **2.** Create a new project (`File` -> `New` -> `Project`)\n\n![](https://i.imgur.com/Twz9SlW.png)\n\n#### **3.** Select `Maven`\n\n#### **4.** Make sure to select an SDK which is 1.8 (or greater)\n\n#### *5.** Click `Next`\n\n![](https://i.imgur.com/OGDuITx.png)\n\n#### **6.** Enter a group id (e.g. `com.github.yourname`)\n\n#### **7.** Enter an artifact id (e.g. `myfirstbot`)\n\n#### **8.** Click `Next`\n\n![](https://i.imgur.com/kWoutrk.png)\n\n#### **9.** Click on `Finish`\n\n![](https://i.imgur.com/pXwWMbi.png)\n\n#### **10.** Your project should now look like this. First click on `Enable Auto-Import`\n\n![](https://i.imgur.com/PXZ6aww.png)\n\n#### **11.** Now you have to add Javacord as a dependency by editing the pom.xml file. Your file should now look like this:\n\n<LatestVersionInfo/>\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>your.package.name</groupId>\n    <artifactId>myfirstbot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.javacord</groupId>\n            <artifactId>javacord</artifactId>\n            <version>$latest-version</version>\n            <type>pom</type>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n#### **12.** Create a new package\n\n![](https://i.imgur.com/EtgpIok.png)\n![](https://i.imgur.com/P4e3RwT.png)\n\n#### **13.** Create a new class inside this package\n\n![](https://i.imgur.com/VVnLssf.png)\n![](https://i.imgur.com/nyl3Jit.png)\n\n#### **14.** You can now start coding! Example code:\n\n```java\npackage com.github.yourname;\n\nimport org.javacord.api.DiscordApi;\nimport org.javacord.api.DiscordApiBuilder;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        // Insert your bot's token here\n        String token = \"your token\";\n\n        DiscordApi api = new DiscordApiBuilder().setToken(token).login().join();\n\n        // Add a listener which answers with \"Pong!\" if someone writes \"!ping\"\n        api.addMessageCreateListener(event -> {\n            if (event.getMessageContent().equalsIgnoreCase(\"!ping\")) {\n                event.getChannel().sendMessage(\"Pong!\");\n            }\n        });\n\n        // Print the invite url of your bot\n        System.out.println(\"You can invite the bot by using the following url: \" + api.createBotInvite());\n    }\n    \n}\n```\n\n## :running_woman: Run the code\n\nYou can run your code by clicking on the small green arrow\n![](https://i.imgur.com/USGlewm.png)\n\n## :construction: Possible problems\n\n**Note:** If you get the following error:\n![](https://i.imgur.com/Q34zZpb.png)\n\nyou have to change your language level to `1.8`\n\n![](https://i.imgur.com/IwQ5LN8.png)","path":"/wiki/getting-started/setup/intellij-maven.html","keywords":[]},{"title":"Writing your first bot","headers":[{"level":2,"title":"üîë Log the bot in","slug":"log-the-bot-in"},{"level":2,"title":"üëÇ Adding a listener","slug":"adding-a-listener"},{"level":2,"title":"üë©‚Äçüîß Putting it all together","slug":"putting-it-all-together"}],"content":"# Writing your first bot\n\nAfter you have successfully added Javacord as a dependency, created a bot user, and got its token, you are now ready to create your first simple bot! :tada:\n\n## :key: Log the bot in\n\nEverything starts with the `DiscordApiBuilder` class.\nIt is used to create a `DiscordApi` object which is the most important class of your bot.\n\n```java\nDiscordApi api = new DiscordApiBuilder()\n        .setToken(\"<your super secret token>\")\n        .login().join();\n```\n\nAfter executing this code, you should already see your bot online in Discord.\nOf course, just being online is not enough, so let's add some more code!\n\n## :ear: Adding a listener\n\nAfter you got your `api` instance, let's continue by adding a listener that answers every `!ping` message with a simple `Pong!`.\n\n```java\napi.addMessageCreateListener(event -> {\n    if (event.getMessageContent().equalsIgnoreCase(\"!ping\")) {\n        event.getChannel().sendMessage(\"Pong!\");\n    }\n});\n```\n\n![](./ping-pong-white.gif)\n\n## :woman_mechanic: Putting it all together\n\nA good place for your code is the `main(...)` method that every executable Java program must have.\nYour complete class may look like this:\n\n```java\npublic class MyFirstBot {\n\n    public static void main(String[] args) {\n        // Log the bot in\n        DiscordApi api = new DiscordApiBuilder()\n                .setToken(\"<your super secret token>\")\n                .login().join();\n\n        // Add a listener which answers with \"Pong!\" if someone writes \"!ping\"\n        api.addMessageCreateListener(event -> {\n            if (event.getMessageContent().equalsIgnoreCase(\"!ping\")) {\n                event.getChannel().sendMessage(\"Pong!\");\n            }\n        });\n    }\n\n}\n```\n\nCongratulations, that's already everything you have to know for the beginning.\nNow, you can play around a little bit by exploring other listeners and methods.\nOr you just continue reading articles in the *Basic Tutorials* category.","path":"/wiki/getting-started/writing-your-first-bot.html","keywords":[]}]